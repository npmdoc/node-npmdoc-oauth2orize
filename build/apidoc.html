<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/jaredhanson/oauth2orize#readme"

    >oauth2orize (v1.8.0)</a>
</h1>
<h4>OAuth 2.0 authorization server toolkit for Node.js.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.oauth2orize">module oauth2orize</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.oauth2orize">
            function <span class="apidocSignatureSpan"></span>oauth2orize
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.AuthorizationError">
            function <span class="apidocSignatureSpan">oauth2orize.</span>AuthorizationError
            <span class="apidocSignatureSpan">(message, code, uri, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.OAuth2Error">
            function <span class="apidocSignatureSpan">oauth2orize.</span>OAuth2Error
            <span class="apidocSignatureSpan">(message, code, uri, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.TokenError">
            function <span class="apidocSignatureSpan">oauth2orize.</span>TokenError
            <span class="apidocSignatureSpan">(message, code, uri, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.createServer">
            function <span class="apidocSignatureSpan">oauth2orize.</span>createServer
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.errorHandler">
            function <span class="apidocSignatureSpan">oauth2orize.</span>errorHandler
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">oauth2orize.</span>exchange</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">oauth2orize.</span>grant</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.oauth2orize.createServer">module oauth2orize.createServer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.createServer.createServer">
            function <span class="apidocSignatureSpan">oauth2orize.</span>createServer
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.createServer.AuthorizationError">
            function <span class="apidocSignatureSpan">oauth2orize.createServer.</span>AuthorizationError
            <span class="apidocSignatureSpan">(message, code, uri, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.createServer.OAuth2Error">
            function <span class="apidocSignatureSpan">oauth2orize.createServer.</span>OAuth2Error
            <span class="apidocSignatureSpan">(message, code, uri, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.createServer.TokenError">
            function <span class="apidocSignatureSpan">oauth2orize.createServer.</span>TokenError
            <span class="apidocSignatureSpan">(message, code, uri, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.createServer.errorHandler">
            function <span class="apidocSignatureSpan">oauth2orize.createServer.</span>errorHandler
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">oauth2orize.createServer.</span>exchange</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">oauth2orize.createServer.</span>grant</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.oauth2orize.exchange">module oauth2orize.exchange</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.exchange.authorizationCode">
            function <span class="apidocSignatureSpan">oauth2orize.exchange.</span>authorizationCode
            <span class="apidocSignatureSpan">(options, issue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.exchange.clientCredentials">
            function <span class="apidocSignatureSpan">oauth2orize.exchange.</span>clientCredentials
            <span class="apidocSignatureSpan">(options, issue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.exchange.code">
            function <span class="apidocSignatureSpan">oauth2orize.exchange.</span>code
            <span class="apidocSignatureSpan">(options, issue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.exchange.password">
            function <span class="apidocSignatureSpan">oauth2orize.exchange.</span>password
            <span class="apidocSignatureSpan">(options, issue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.exchange.refreshToken">
            function <span class="apidocSignatureSpan">oauth2orize.exchange.</span>refreshToken
            <span class="apidocSignatureSpan">(options, issue)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.oauth2orize.grant">module oauth2orize.grant</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.grant.authorizationCode">
            function <span class="apidocSignatureSpan">oauth2orize.grant.</span>authorizationCode
            <span class="apidocSignatureSpan">(options, issue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.grant.code">
            function <span class="apidocSignatureSpan">oauth2orize.grant.</span>code
            <span class="apidocSignatureSpan">(options, issue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.grant.implicit">
            function <span class="apidocSignatureSpan">oauth2orize.grant.</span>implicit
            <span class="apidocSignatureSpan">(options, issue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.grant.token">
            function <span class="apidocSignatureSpan">oauth2orize.grant.</span>token
            <span class="apidocSignatureSpan">(options, issue)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.oauth2orize" id="apidoc.module.oauth2orize">module oauth2orize</a></h1>


    <h2>
        <a href="#apidoc.element.oauth2orize.oauth2orize" id="apidoc.element.oauth2orize.oauth2orize">
        function <span class="apidocSignatureSpan"></span>oauth2orize
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createServer(options) {
  var server = new Server(options);
  return server;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.AuthorizationError" id="apidoc.element.oauth2orize.AuthorizationError">
        function <span class="apidocSignatureSpan">oauth2orize.</span>AuthorizationError
        <span class="apidocSignatureSpan">(message, code, uri, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AuthorizationError(message, code, uri, status) {
  if (!status) {
    switch (code) {
      case &#x27;invalid_request&#x27;: status = 400; break;
      case &#x27;unauthorized_client&#x27;: status = 403; break;
      case &#x27;access_denied&#x27;: status = 403; break;
      case &#x27;unsupported_response_type&#x27;: status = 501; break;
      case &#x27;invalid_scope&#x27;: status = 400; break;
      case &#x27;temporarily_unavailable&#x27;: status = 503; break;
    }
  }

  OAuth2Error.call(this, message, code, uri, status);
  Error.captureStackTrace(this, arguments.callee);
  this.name = &#x27;AuthorizationError&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.OAuth2Error" id="apidoc.element.oauth2orize.OAuth2Error">
        function <span class="apidocSignatureSpan">oauth2orize.</span>OAuth2Error
        <span class="apidocSignatureSpan">(message, code, uri, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OAuth2Error(message, code, uri, status) {
  Error.call(this);
  this.message = message;
  this.code = code || &#x27;server_error&#x27;;
  this.uri = uri;
  this.status = status || 500;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.TokenError" id="apidoc.element.oauth2orize.TokenError">
        function <span class="apidocSignatureSpan">oauth2orize.</span>TokenError
        <span class="apidocSignatureSpan">(message, code, uri, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TokenError(message, code, uri, status) {
  if (!status) {
    switch (code) {
      case &#x27;invalid_request&#x27;: status = 400; break;
      case &#x27;invalid_client&#x27;: status = 401; break;
      case &#x27;invalid_grant&#x27;: status = 403; break;
      case &#x27;unauthorized_client&#x27;: status = 403; break;
      case &#x27;unsupported_grant_type&#x27;: status = 501; break;
      case &#x27;invalid_scope&#x27;: status = 400; break;
    }
  }

  OAuth2Error.call(this, message, code, uri, status);
  Error.captureStackTrace(this, arguments.callee);
  this.name = &#x27;TokenError&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.createServer" id="apidoc.element.oauth2orize.createServer">
        function <span class="apidocSignatureSpan">oauth2orize.</span>createServer
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createServer(options) {
  var server = new Server(options);
  return server;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### Create an OAuth Server

Call `createServer()` to create a new OAuth 2.0 server.  This instance exposes
middleware that will be mounted in routes, as well as configuration options.

```javascript
var server = oauth2orize.<span class="apidocCodeKeywordSpan">createServer</span>();
```

#### Register Grants

A client must obtain permission from a user before it is issued an access token.
This permission is known as a grant, the most common type of which is an
authorization code.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.errorHandler" id="apidoc.element.oauth2orize.errorHandler">
        function <span class="apidocSignatureSpan">oauth2orize.</span>errorHandler
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">errorHandler = function (options) {
  options = options || {};

  var mode = options.mode || &#x27;direct&#x27;
    , fragment = options.fragment || [&#x27;token&#x27;]
    , modes = options.modes || {};

  if (!modes.query) {
    modes.query = require(&#x27;../response/query&#x27;);
  }
  if (!modes.fragment) {
    modes.fragment = require(&#x27;../response/fragment&#x27;);
  }

  return function errorHandler(err, req, res, next) {
    if (mode == &#x27;direct&#x27;) {
      if (err.status) { res.statusCode = err.status; }
      if (!res.statusCode || res.statusCode &#x3c; 400) { res.statusCode = 500; }

      if (res.statusCode == 401) {
        // TODO: set WWW-Authenticate header
      }

      var e = {};
      e.error = err.code || &#x27;server_error&#x27;;
      if (err.message) { e.error_description = err.message; }
      if (err.uri) { e.error_uri = err.uri; }

      res.setHeader(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;);
      return res.end(JSON.stringify(e));
    } else if (mode == &#x27;indirect&#x27;) {
      // If the redirectURI for this OAuth 2.0 transaction is invalid, the user
      // agent will not be redirected and the client will not be informed.  `next`
      // immediately into the application&#x27;s error handler, so a message can be
      // displayed to the user.
      if (!req.oauth2 || !req.oauth2.redirectURI) { return next(err); }

      var enc = &#x27;query&#x27;;
      if (req.oauth2.req) {
        var type = new UnorderedList(req.oauth2.req.type);
        // In accordance with [OAuth 2.0 Multiple Response Type Encoding
        // Practices - draft 08](http://openid.net/specs/oauth-v2-multiple-response-types-1_0.html),
        // if the response type contains any value that requires fragment
        // encoding, the response will be fragment encoded.
        if (type.containsAny(fragment)) { enc = &#x27;fragment&#x27;; }
        if (req.oauth2.req.responseMode) {
          // Encode the response using the requested mode, if specified.
          enc = req.oauth2.req.responseMode;
        }
      }

      var respond = modes[enc]
        , params = {};

      if (!respond) { return next(err); }

      params.error = err.code || &#x27;server_error&#x27;;
      if (err.message) { params.error_description = err.message; }
      if (err.uri) { params.error_uri = err.uri; }
      if (req.oauth2.req &#x26;&#x26; req.oauth2.req.state) { params.state = req.oauth2.req.state; }
      return respond(req.oauth2, res, params);
    } else {
      return next(err);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Once a user has approved access, the authorization grant can be exchanged by the
client for an access token.

```javascript
app.post(&#x27;/token&#x27;,
  passport.authenticate([&#x27;basic&#x27;, &#x27;oauth2-client-password&#x27;], { session: false }),
  server.token(),
  server.<span class="apidocCodeKeywordSpan">errorHandler</span>());
```

[Passport](http://passportjs.org/) strategies are used to authenticate the
client, in this case using either an HTTP Basic authentication header (as
provided by [passport-http](https://github.com/jaredhanson/passport-http)) or
client credentials in the request body (as provided by
[passport-oauth2-client-password](https://github.com/jaredhanson/passport-oauth2-client-password)).
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.oauth2orize.createServer" id="apidoc.module.oauth2orize.createServer">module oauth2orize.createServer</a></h1>


    <h2>
        <a href="#apidoc.element.oauth2orize.createServer.createServer" id="apidoc.element.oauth2orize.createServer.createServer">
        function <span class="apidocSignatureSpan">oauth2orize.</span>createServer
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createServer(options) {
  var server = new Server(options);
  return server;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### Create an OAuth Server

Call `createServer()` to create a new OAuth 2.0 server.  This instance exposes
middleware that will be mounted in routes, as well as configuration options.

```javascript
var server = oauth2orize.<span class="apidocCodeKeywordSpan">createServer</span>();
```

#### Register Grants

A client must obtain permission from a user before it is issued an access token.
This permission is known as a grant, the most common type of which is an
authorization code.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.createServer.AuthorizationError" id="apidoc.element.oauth2orize.createServer.AuthorizationError">
        function <span class="apidocSignatureSpan">oauth2orize.createServer.</span>AuthorizationError
        <span class="apidocSignatureSpan">(message, code, uri, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AuthorizationError(message, code, uri, status) {
  if (!status) {
    switch (code) {
      case &#x27;invalid_request&#x27;: status = 400; break;
      case &#x27;unauthorized_client&#x27;: status = 403; break;
      case &#x27;access_denied&#x27;: status = 403; break;
      case &#x27;unsupported_response_type&#x27;: status = 501; break;
      case &#x27;invalid_scope&#x27;: status = 400; break;
      case &#x27;temporarily_unavailable&#x27;: status = 503; break;
    }
  }

  OAuth2Error.call(this, message, code, uri, status);
  Error.captureStackTrace(this, arguments.callee);
  this.name = &#x27;AuthorizationError&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.createServer.OAuth2Error" id="apidoc.element.oauth2orize.createServer.OAuth2Error">
        function <span class="apidocSignatureSpan">oauth2orize.createServer.</span>OAuth2Error
        <span class="apidocSignatureSpan">(message, code, uri, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OAuth2Error(message, code, uri, status) {
  Error.call(this);
  this.message = message;
  this.code = code || &#x27;server_error&#x27;;
  this.uri = uri;
  this.status = status || 500;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.createServer.TokenError" id="apidoc.element.oauth2orize.createServer.TokenError">
        function <span class="apidocSignatureSpan">oauth2orize.createServer.</span>TokenError
        <span class="apidocSignatureSpan">(message, code, uri, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TokenError(message, code, uri, status) {
  if (!status) {
    switch (code) {
      case &#x27;invalid_request&#x27;: status = 400; break;
      case &#x27;invalid_client&#x27;: status = 401; break;
      case &#x27;invalid_grant&#x27;: status = 403; break;
      case &#x27;unauthorized_client&#x27;: status = 403; break;
      case &#x27;unsupported_grant_type&#x27;: status = 501; break;
      case &#x27;invalid_scope&#x27;: status = 400; break;
    }
  }

  OAuth2Error.call(this, message, code, uri, status);
  Error.captureStackTrace(this, arguments.callee);
  this.name = &#x27;TokenError&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.createServer.errorHandler" id="apidoc.element.oauth2orize.createServer.errorHandler">
        function <span class="apidocSignatureSpan">oauth2orize.createServer.</span>errorHandler
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">errorHandler = function (options) {
  options = options || {};

  var mode = options.mode || &#x27;direct&#x27;
    , fragment = options.fragment || [&#x27;token&#x27;]
    , modes = options.modes || {};

  if (!modes.query) {
    modes.query = require(&#x27;../response/query&#x27;);
  }
  if (!modes.fragment) {
    modes.fragment = require(&#x27;../response/fragment&#x27;);
  }

  return function errorHandler(err, req, res, next) {
    if (mode == &#x27;direct&#x27;) {
      if (err.status) { res.statusCode = err.status; }
      if (!res.statusCode || res.statusCode &#x3c; 400) { res.statusCode = 500; }

      if (res.statusCode == 401) {
        // TODO: set WWW-Authenticate header
      }

      var e = {};
      e.error = err.code || &#x27;server_error&#x27;;
      if (err.message) { e.error_description = err.message; }
      if (err.uri) { e.error_uri = err.uri; }

      res.setHeader(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;);
      return res.end(JSON.stringify(e));
    } else if (mode == &#x27;indirect&#x27;) {
      // If the redirectURI for this OAuth 2.0 transaction is invalid, the user
      // agent will not be redirected and the client will not be informed.  `next`
      // immediately into the application&#x27;s error handler, so a message can be
      // displayed to the user.
      if (!req.oauth2 || !req.oauth2.redirectURI) { return next(err); }

      var enc = &#x27;query&#x27;;
      if (req.oauth2.req) {
        var type = new UnorderedList(req.oauth2.req.type);
        // In accordance with [OAuth 2.0 Multiple Response Type Encoding
        // Practices - draft 08](http://openid.net/specs/oauth-v2-multiple-response-types-1_0.html),
        // if the response type contains any value that requires fragment
        // encoding, the response will be fragment encoded.
        if (type.containsAny(fragment)) { enc = &#x27;fragment&#x27;; }
        if (req.oauth2.req.responseMode) {
          // Encode the response using the requested mode, if specified.
          enc = req.oauth2.req.responseMode;
        }
      }

      var respond = modes[enc]
        , params = {};

      if (!respond) { return next(err); }

      params.error = err.code || &#x27;server_error&#x27;;
      if (err.message) { params.error_description = err.message; }
      if (err.uri) { params.error_uri = err.uri; }
      if (req.oauth2.req &#x26;&#x26; req.oauth2.req.state) { params.state = req.oauth2.req.state; }
      return respond(req.oauth2, res, params);
    } else {
      return next(err);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Once a user has approved access, the authorization grant can be exchanged by the
client for an access token.

```javascript
app.post(&#x27;/token&#x27;,
  passport.authenticate([&#x27;basic&#x27;, &#x27;oauth2-client-password&#x27;], { session: false }),
  server.token(),
  server.<span class="apidocCodeKeywordSpan">errorHandler</span>());
```

[Passport](http://passportjs.org/) strategies are used to authenticate the
client, in this case using either an HTTP Basic authentication header (as
provided by [passport-http](https://github.com/jaredhanson/passport-http)) or
client credentials in the request body (as provided by
[passport-oauth2-client-password](https://github.com/jaredhanson/passport-oauth2-client-password)).
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.oauth2orize.exchange" id="apidoc.module.oauth2orize.exchange">module oauth2orize.exchange</a></h1>


    <h2>
        <a href="#apidoc.element.oauth2orize.exchange.authorizationCode" id="apidoc.element.oauth2orize.exchange.authorizationCode">
        function <span class="apidocSignatureSpan">oauth2orize.exchange.</span>authorizationCode
        <span class="apidocSignatureSpan">(options, issue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authorizationCode = function (options, issue) {
  if (typeof options == &#x27;function&#x27;) {
    issue = options;
    options = undefined;
  }
  options = options || {};

  if (!issue) { throw new TypeError(&#x27;oauth2orize.authorizationCode exchange requires an issue callback&#x27;); }

  var userProperty = options.userProperty || &#x27;user&#x27;;

  return function authorization_code(req, res, next) {
    if (!req.body) { return next(new Error(&#x27;OAuth2orize requires body parsing. Did you forget app.use(express.bodyParser())?&#x27;)); }

    // The &#x27;user&#x27; property of `req` holds the authenticated user.  In the case
    // of the token endpoint, the property will contain the OAuth 2.0 client.
    var client = req[userProperty]
      , code = req.body.code
      , redirectURI = req.body.redirect_uri;

    if (!code) { return next(new TokenError(&#x27;Missing required parameter: code&#x27;, &#x27;invalid_request&#x27;)); }

    function issued(err, accessToken, refreshToken, params) {
      if (err) { return next(err); }
      if (!accessToken) { return next(new TokenError(&#x27;Invalid authorization code&#x27;, &#x27;invalid_grant&#x27;)); }
      if (refreshToken &#x26;&#x26; typeof refreshToken == &#x27;object&#x27;) {
        params = refreshToken;
        refreshToken = null;
      }

      var tok = {};
      tok.access_token = accessToken;
      if (refreshToken) { tok.refresh_token = refreshToken; }
      if (params) { utils.merge(tok, params); }
      tok.token_type = tok.token_type || &#x27;Bearer&#x27;;

      var json = JSON.stringify(tok);
      res.setHeader(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;);
      res.setHeader(&#x27;Cache-Control&#x27;, &#x27;no-store&#x27;);
      res.setHeader(&#x27;Pragma&#x27;, &#x27;no-cache&#x27;);
      res.end(json);
    }

    try {
      var arity = issue.length;
      if (arity == 6) {
        issue(client, code, redirectURI, req.body, req.authInfo, issued);
      } else if (arity == 5) {
        issue(client, code, redirectURI, req.body, issued);
      } else { // arity == 4
        issue(client, code, redirectURI, issued);
      }
    } catch (ex) {
      return next(ex);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* OAuth 2.0 defines an authorization framework, in which authorization grants
* can be of a variety of types.  Exchanging of these types for access tokens is
* implemented by exchange middleware, and the server registers the middleware
* it wishes to support.
*
* Examples:
*
*     server.exchange(oauth2orize.exchange.<span class="apidocCodeKeywordSpan">authorizationCode</span>(function() {
*       ...
*     }));
*
* @param {String|Function} type
* @param {Function} fn
* @return {Server} for chaining
* @api public
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.exchange.clientCredentials" id="apidoc.element.oauth2orize.exchange.clientCredentials">
        function <span class="apidocSignatureSpan">oauth2orize.exchange.</span>clientCredentials
        <span class="apidocSignatureSpan">(options, issue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clientCredentials = function (options, issue) {
  if (typeof options == &#x27;function&#x27;) {
    issue = options;
    options = undefined;
  }
  options = options || {};

  if (!issue) { throw new TypeError(&#x27;oauth2orize.clientCredentials exchange requires an issue callback&#x27;); }

  var userProperty = options.userProperty || &#x27;user&#x27;;

  // For maximum flexibility, multiple scope spearators can optionally be
  // allowed.  This allows the server to accept clients that separate scope
  // with either space or comma (&#x27; &#x27;, &#x27;,&#x27;).  This violates the specification,
  // but achieves compatibility with existing client libraries that are already
  // deployed.
  var separators = options.scopeSeparator || &#x27; &#x27;;
  if (!Array.isArray(separators)) {
    separators = [ separators ];
  }

  return function client_credentials(req, res, next) {
    if (!req.body) { return next(new Error(&#x27;OAuth2orize requires body parsing. Did you forget app.use(express.bodyParser())?&#x27;)); }

    // The &#x27;user&#x27; property of `req` holds the authenticated user.  In the case
    // of the token endpoint, the property will contain the OAuth 2.0 client.
    var client = req[userProperty]
      , scope = req.body.scope;

    if (scope) {
      for (var i = 0, len = separators.length; i &#x3c; len; i++) {
        var separated = scope.split(separators[i]);
        // only separate on the first matching separator.  this allows for a sort
        // of separator &#x22;priority&#x22; (ie, favor spaces then fallback to commas)
        if (separated.length &#x3e; 1) {
          scope = separated;
          break;
        }
      }
      if (!Array.isArray(scope)) { scope = [ scope ]; }
    }

    function issued(err, accessToken, refreshToken, params) {
      if (err) { return next(err); }
      if (!accessToken) { return next(new TokenError(&#x27;Invalid client credentials&#x27;, &#x27;invalid_grant&#x27;)); }
      if (refreshToken &#x26;&#x26; typeof refreshToken == &#x27;object&#x27;) {
        params = refreshToken;
        refreshToken = null;
      }

      var tok = {};
      tok.access_token = accessToken;
      if (refreshToken) { tok.refresh_token = refreshToken; }
      if (params) { utils.merge(tok, params); }
      tok.token_type = tok.token_type || &#x27;Bearer&#x27;;

      var json = JSON.stringify(tok);
      res.setHeader(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;);
      res.setHeader(&#x27;Cache-Control&#x27;, &#x27;no-store&#x27;);
      res.setHeader(&#x27;Pragma&#x27;, &#x27;no-cache&#x27;);
      res.end(json);
    }

    try {
      var arity = issue.length;
      if (arity == 5) {
        issue(client, scope, req.body, req.authInfo, issued);
      } else if (arity == 4) {
        issue(client, scope, req.body, issued);
      } else if (arity == 3) {
        issue(client, scope, issued);
      } else { // arity == 2
        issue(client, issued);
      }
    } catch (ex) {
      return next(ex);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Options:
*
*     userProperty    property of `req` which contains the authenticated client (default: &#x27;user&#x27;)
*     scopeSeparator  separator used to demarcate scope values (default: &#x27; &#x27;)
*
* Examples:
*
*     server.exchange(oauth2orize.exchange.<span class="apidocCodeKeywordSpan">clientCredentials</span>(function(client, scope,
done) {
*       AccessToken.create(client, scope, function(err, accessToken) {
*         if (err) { return done(err); }
*         done(null, accessToken);
*       });
*     }));
*
* References:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.exchange.code" id="apidoc.element.oauth2orize.exchange.code">
        function <span class="apidocSignatureSpan">oauth2orize.exchange.</span>code
        <span class="apidocSignatureSpan">(options, issue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">code = function (options, issue) {
  if (typeof options == &#x27;function&#x27;) {
    issue = options;
    options = undefined;
  }
  options = options || {};

  if (!issue) { throw new TypeError(&#x27;oauth2orize.authorizationCode exchange requires an issue callback&#x27;); }

  var userProperty = options.userProperty || &#x27;user&#x27;;

  return function authorization_code(req, res, next) {
    if (!req.body) { return next(new Error(&#x27;OAuth2orize requires body parsing. Did you forget app.use(express.bodyParser())?&#x27;)); }

    // The &#x27;user&#x27; property of `req` holds the authenticated user.  In the case
    // of the token endpoint, the property will contain the OAuth 2.0 client.
    var client = req[userProperty]
      , code = req.body.code
      , redirectURI = req.body.redirect_uri;

    if (!code) { return next(new TokenError(&#x27;Missing required parameter: code&#x27;, &#x27;invalid_request&#x27;)); }

    function issued(err, accessToken, refreshToken, params) {
      if (err) { return next(err); }
      if (!accessToken) { return next(new TokenError(&#x27;Invalid authorization code&#x27;, &#x27;invalid_grant&#x27;)); }
      if (refreshToken &#x26;&#x26; typeof refreshToken == &#x27;object&#x27;) {
        params = refreshToken;
        refreshToken = null;
      }

      var tok = {};
      tok.access_token = accessToken;
      if (refreshToken) { tok.refresh_token = refreshToken; }
      if (params) { utils.merge(tok, params); }
      tok.token_type = tok.token_type || &#x27;Bearer&#x27;;

      var json = JSON.stringify(tok);
      res.setHeader(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;);
      res.setHeader(&#x27;Cache-Control&#x27;, &#x27;no-store&#x27;);
      res.setHeader(&#x27;Pragma&#x27;, &#x27;no-cache&#x27;);
      res.end(json);
    }

    try {
      var arity = issue.length;
      if (arity == 6) {
        issue(client, code, redirectURI, req.body, req.authInfo, issued);
      } else if (arity == 5) {
        issue(client, code, redirectURI, req.body, issued);
      } else { // arity == 4
        issue(client, code, redirectURI, issued);
      }
    } catch (ex) {
      return next(ex);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### Register Grants

A client must obtain permission from a user before it is issued an access token.
This permission is known as a grant, the most common type of which is an
authorization code.
```javascript
server.grant(oauth2orize.grant.<span class="apidocCodeKeywordSpan">code</span>(function(client, redirectURI, user, ares, done) {
var code = utils.uid(16);

var ac = new AuthorizationCode(code, client.id, redirectURI, user.id, ares.scope);
ac.save(function(err) {
  if (err) { return done(err); }
  return done(null, code);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.exchange.password" id="apidoc.element.oauth2orize.exchange.password">
        function <span class="apidocSignatureSpan">oauth2orize.exchange.</span>password
        <span class="apidocSignatureSpan">(options, issue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">password = function (options, issue) {
  if (typeof options == &#x27;function&#x27;) {
    issue = options;
    options = undefined;
  }
  options = options || {};

  if (!issue) { throw new TypeError(&#x27;oauth2orize.password exchange requires an issue callback&#x27;); }

  var userProperty = options.userProperty || &#x27;user&#x27;;

  // For maximum flexibility, multiple scope spearators can optionally be
  // allowed.  This allows the server to accept clients that separate scope
  // with either space or comma (&#x27; &#x27;, &#x27;,&#x27;).  This violates the specification,
  // but achieves compatibility with existing client libraries that are already
  // deployed.
  var separators = options.scopeSeparator || &#x27; &#x27;;
  if (!Array.isArray(separators)) {
    separators = [ separators ];
  }

  return function password(req, res, next) {
    if (!req.body) { return next(new Error(&#x27;OAuth2orize requires body parsing. Did you forget app.use(express.bodyParser())?&#x27;)); }

    // The &#x27;user&#x27; property of `req` holds the authenticated user.  In the case
    // of the token endpoint, the property will contain the OAuth 2.0 client.
    var client = req[userProperty]
      , username = req.body.username
      , passwd = req.body.password
      , scope = req.body.scope;

    if (!username) { return next(new TokenError(&#x27;Missing required parameter: username&#x27;, &#x27;invalid_request&#x27;)); }
    if (!passwd) { return next(new TokenError(&#x27;Missing required parameter: password&#x27;, &#x27;invalid_request&#x27;)); }

    if (scope) {
      for (var i = 0, len = separators.length; i &#x3c; len; i++) {
        var separated = scope.split(separators[i]);
        // only separate on the first matching separator.  this allows for a sort
        // of separator &#x22;priority&#x22; (ie, favor spaces then fallback to commas)
        if (separated.length &#x3e; 1) {
          scope = separated;
          break;
        }
      }
      if (!Array.isArray(scope)) { scope = [ scope ]; }
    }

    function issued(err, accessToken, refreshToken, params) {
      if (err) { return next(err); }
      if (!accessToken) { return next(new TokenError(&#x27;Invalid resource owner credentials&#x27;, &#x27;invalid_grant&#x27;)); }
      if (refreshToken &#x26;&#x26; typeof refreshToken == &#x27;object&#x27;) {
        params = refreshToken;
        refreshToken = null;
      }

      var tok = {};
      tok.access_token = accessToken;
      if (refreshToken) { tok.refresh_token = refreshToken; }
      if (params) { utils.merge(tok, params); }
      tok.token_type = tok.token_type || &#x27;Bearer&#x27;;

      var json = JSON.stringify(tok);
      res.setHeader(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;);
      res.setHeader(&#x27;Cache-Control&#x27;, &#x27;no-store&#x27;);
      res.setHeader(&#x27;Pragma&#x27;, &#x27;no-cache&#x27;);
      res.end(json);
    }

    try {
      var arity = issue.length;
      if (arity == 7) {
        issue(client, username, passwd, scope, req.body, req.authInfo, issued);
      } else if (arity == 6) {
        issue(client, username, passwd, scope, req.body, issued);
      } else if (arity == 5) {
        issue(client, username, passwd, scope, issued);
      } else { // arity == 4
        issue(client, username, passwd, issued);
      }
    } catch (ex) {
      return next(ex);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Options:
*
*     userProperty    property of `req` which contains the authenticated client (default: &#x27;user&#x27;)
*     scopeSeparator  separator used to demarcate scope values (default: &#x27; &#x27;)
*
* Examples:
*
*     server.exchange(oauth2orize.exchange.<span class="apidocCodeKeywordSpan">password</span>(function(client, username, password
, scope, done) {
*       AccessToken.create(client, username, password, scope, function(err, accessToken) {
*         if (err) { return done(err); }
*         done(null, accessToken);
*       });
*     }));
*
* References:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.exchange.refreshToken" id="apidoc.element.oauth2orize.exchange.refreshToken">
        function <span class="apidocSignatureSpan">oauth2orize.exchange.</span>refreshToken
        <span class="apidocSignatureSpan">(options, issue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">refreshToken = function (options, issue) {
  if (typeof options == &#x27;function&#x27;) {
    issue = options;
    options = undefined;
  }
  options = options || {};

  if (!issue) { throw new TypeError(&#x27;oauth2orize.refreshToken exchange requires an issue callback&#x27;); }

  var userProperty = options.userProperty || &#x27;user&#x27;;

  // For maximum flexibility, multiple scope spearators can optionally be
  // allowed.  This allows the server to accept clients that separate scope
  // with either space or comma (&#x27; &#x27;, &#x27;,&#x27;).  This violates the specification,
  // but achieves compatibility with existing client libraries that are already
  // deployed.
  var separators = options.scopeSeparator || &#x27; &#x27;;
  if (!Array.isArray(separators)) {
    separators = [ separators ];
  }

  return function refresh_token(req, res, next) {
    if (!req.body) { return next(new Error(&#x27;OAuth2orize requires body parsing. Did you forget app.use(express.bodyParser())?&#x27;)); }

    // The &#x27;user&#x27; property of `req` holds the authenticated user.  In the case
    // of the token endpoint, the property will contain the OAuth 2.0 client.
    var client = req[userProperty]
      , refreshToken = req.body.refresh_token
      , scope = req.body.scope;

    if (!refreshToken) { return next(new TokenError(&#x27;Missing required parameter: refresh_token&#x27;, &#x27;invalid_request&#x27;)); }

    if (scope) {
      for (var i = 0, len = separators.length; i &#x3c; len; i++) {
        var separated = scope.split(separators[i]);
        // only separate on the first matching separator.  this allows for a sort
        // of separator &#x22;priority&#x22; (ie, favor spaces then fallback to commas)
        if (separated.length &#x3e; 1) {
          scope = separated;
          break;
        }
      }
      if (!Array.isArray(scope)) { scope = [ scope ]; }
    }

    function issued(err, accessToken, refreshToken, params) {
      if (err) { return next(err); }
      if (!accessToken) { return next(new TokenError(&#x27;Invalid refresh token&#x27;, &#x27;invalid_grant&#x27;)); }
      if (refreshToken &#x26;&#x26; typeof refreshToken == &#x27;object&#x27;) {
        params = refreshToken;
        refreshToken = null;
      }

      var tok = {};
      tok.access_token = accessToken;
      if (refreshToken) { tok.refresh_token = refreshToken; }
      if (params) { utils.merge(tok, params); }
      tok.token_type = tok.token_type || &#x27;Bearer&#x27;;

      var json = JSON.stringify(tok);
      res.setHeader(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;);
      res.setHeader(&#x27;Cache-Control&#x27;, &#x27;no-store&#x27;);
      res.setHeader(&#x27;Pragma&#x27;, &#x27;no-cache&#x27;);
      res.end(json);
    }

    try {
      var arity = issue.length;
      if (arity == 6) {
        issue(client, refreshToken, scope, req.body, req.authInfo, issued);
      } else if (arity == 5) {
        issue(client, refreshToken, scope, req.body, issued);
      } else if (arity == 4) {
        issue(client, refreshToken, scope, issued);
      } else { // arity == 3
        issue(client, refreshToken, issued);
      }
    } catch (ex) {
      return next(ex);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Options:
*
*     userProperty    property of `req` which contains the authenticated client (default: &#x27;user&#x27;)
*     scopeSeparator  separator used to demarcate scope values (default: &#x27; &#x27;)
*
* Examples:
*
*     server.exchange(oauth2orize.exchange.<span class="apidocCodeKeywordSpan">refreshToken</span>(function(client, refreshToken
, scope, done) {
*       AccessToken.create(client, refreshToken, scope, function(err, accessToken) {
*         if (err) { return done(err); }
*         done(null, accessToken);
*       });
*     }));
*
* References:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.oauth2orize.grant" id="apidoc.module.oauth2orize.grant">module oauth2orize.grant</a></h1>


    <h2>
        <a href="#apidoc.element.oauth2orize.grant.authorizationCode" id="apidoc.element.oauth2orize.grant.authorizationCode">
        function <span class="apidocSignatureSpan">oauth2orize.grant.</span>authorizationCode
        <span class="apidocSignatureSpan">(options, issue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function code(options, issue) {
  if (typeof options == &#x27;function&#x27;) {
    issue = options;
    options = undefined;
  }
  options = options || {};

  if (!issue) { throw new TypeError(&#x27;oauth2orize.code grant requires an issue callback&#x27;); }

  var modes = options.modes || {};
  if (!modes.query) {
    modes.query = require(&#x27;../response/query&#x27;);
  }

  // For maximum flexibility, multiple scope spearators can optionally be
  // allowed.  This allows the server to accept clients that separate scope
  // with either space or comma (&#x27; &#x27;, &#x27;,&#x27;).  This violates the specification,
  // but achieves compatibility with existing client libraries that are already
  // deployed.
  var separators = options.scopeSeparator || &#x27; &#x27;;
  if (!Array.isArray(separators)) {
    separators = [ separators ];
  }


<span class="apidocCodeCommentSpan">  /* Parse requests that request `code` as `response_type`.
   *
   * @param {http.ServerRequest} req
   * @api public
   */
</span>  function request(req) {
    var clientID = req.query.client_id
      , redirectURI = req.query.redirect_uri
      , scope = req.query.scope
      , state = req.query.state;

    if (!clientID) { throw new AuthorizationError(&#x27;Missing required parameter: client_id&#x27;, &#x27;invalid_request&#x27;); }
    if (typeof clientID !== &#x27;string&#x27;) { throw new AuthorizationError(&#x27;Invalid parameter: client_id must be a string&#x27;, &#x27;invalid_request
&#x27;); }

    if (scope) {
      if (typeof scope !== &#x27;string&#x27;) {
        throw new AuthorizationError(&#x27;Invalid parameter: scope must be a string&#x27;, &#x27;invalid_request&#x27;);
      }

      for (var i = 0, len = separators.length; i &#x3c; len; i++) {
        var separated = scope.split(separators[i]);
        // only separate on the first matching separator.  this allows for a sort
        // of separator &#x22;priority&#x22; (ie, favor spaces then fallback to commas)
        if (separated.length &#x3e; 1) {
          scope = separated;
          break;
        }
      }

      if (!Array.isArray(scope)) { scope = [ scope ]; }
    }

    return {
      clientID: clientID,
      redirectURI: redirectURI,
      scope: scope,
      state: state
    };
  }

  /* Sends responses to transactions that request `code` as `response_type`.
   *
   * @param {Object} txn
   * @param {http.ServerResponse} res
   * @param {Function} next
   * @api public
   */
  function response(txn, res, complete, next) {
    var mode = &#x27;query&#x27;
      , respond;
    if (txn.req &#x26;&#x26; txn.req.responseMode) {
      mode = txn.req.responseMode;
    }
    respond = modes[mode];

    if (!respond) {
      // http://lists.openid.net/pipermail/openid-specs-ab/Week-of-Mon-20140317/004680.html
      return next(new AuthorizationError(&#x27;Unsupported response mode: &#x27; + mode, &#x27;unsupported_response_mode&#x27;, null, 501));
    }
    if (respond &#x26;&#x26; respond.validate) {
      try {
        respond.validate(txn);
      } catch(ex) {
        return next(ex);
      }
    }

    if (!txn.res.allow) {
      var params = { error: &#x27;access_denied&#x27; };
      if (txn.req &#x26;&#x26; txn.req.state) { params.state = txn.req.state; }
      return respond(txn, res, params);
    }

    function issued(err, code) {
      if (err) { return next(err); }
      if (!code) { return next(new AuthorizationError(&#x27;Request denied by authorization server&#x27;, &#x27;access_denied&#x27;)); }

      var params = { code: code };
      if (txn.req &#x26;&#x26; txn.req.state) { params.state = txn.req.state; }
      complete(function(err) {
        if (err) { return next(err); }
        return respond(txn, res, params);
      });
    }

    // NOTE: The `redirect_uri`, if present in the client&#x27;s authorization
    //       request, must also be present in the subsequent request to exchange
    //       the authorization code for an access token.  Acting as a verifier,
    //       the two values must be equal and serve to protect against certain
    //       types of attacks.  More information can be found here:
    //
    //       http://hueniverse.com/2011/06/oauth-2-0-redirection-uri-validation/

    try {
      var arity = issue.length;
      if (arity == 7) {
        issue(txn.client, txn ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* OAuth 2.0 defines an authorization framework, in which authorization grants
* can be of a variety of types.  Exchanging of these types for access tokens is
* implemented by exchange middleware, and the server registers the middleware
* it wishes to support.
*
* Examples:
*
*     server.exchange(oauth2orize.exchange.<span class="apidocCodeKeywordSpan">authorizationCode</span>(function() {
*       ...
*     }));
*
* @param {String|Function} type
* @param {Function} fn
* @return {Server} for chaining
* @api public
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.grant.code" id="apidoc.element.oauth2orize.grant.code">
        function <span class="apidocSignatureSpan">oauth2orize.grant.</span>code
        <span class="apidocSignatureSpan">(options, issue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function code(options, issue) {
  if (typeof options == &#x27;function&#x27;) {
    issue = options;
    options = undefined;
  }
  options = options || {};

  if (!issue) { throw new TypeError(&#x27;oauth2orize.code grant requires an issue callback&#x27;); }

  var modes = options.modes || {};
  if (!modes.query) {
    modes.query = require(&#x27;../response/query&#x27;);
  }

  // For maximum flexibility, multiple scope spearators can optionally be
  // allowed.  This allows the server to accept clients that separate scope
  // with either space or comma (&#x27; &#x27;, &#x27;,&#x27;).  This violates the specification,
  // but achieves compatibility with existing client libraries that are already
  // deployed.
  var separators = options.scopeSeparator || &#x27; &#x27;;
  if (!Array.isArray(separators)) {
    separators = [ separators ];
  }


<span class="apidocCodeCommentSpan">  /* Parse requests that request `code` as `response_type`.
   *
   * @param {http.ServerRequest} req
   * @api public
   */
</span>  function request(req) {
    var clientID = req.query.client_id
      , redirectURI = req.query.redirect_uri
      , scope = req.query.scope
      , state = req.query.state;

    if (!clientID) { throw new AuthorizationError(&#x27;Missing required parameter: client_id&#x27;, &#x27;invalid_request&#x27;); }
    if (typeof clientID !== &#x27;string&#x27;) { throw new AuthorizationError(&#x27;Invalid parameter: client_id must be a string&#x27;, &#x27;invalid_request
&#x27;); }

    if (scope) {
      if (typeof scope !== &#x27;string&#x27;) {
        throw new AuthorizationError(&#x27;Invalid parameter: scope must be a string&#x27;, &#x27;invalid_request&#x27;);
      }

      for (var i = 0, len = separators.length; i &#x3c; len; i++) {
        var separated = scope.split(separators[i]);
        // only separate on the first matching separator.  this allows for a sort
        // of separator &#x22;priority&#x22; (ie, favor spaces then fallback to commas)
        if (separated.length &#x3e; 1) {
          scope = separated;
          break;
        }
      }

      if (!Array.isArray(scope)) { scope = [ scope ]; }
    }

    return {
      clientID: clientID,
      redirectURI: redirectURI,
      scope: scope,
      state: state
    };
  }

  /* Sends responses to transactions that request `code` as `response_type`.
   *
   * @param {Object} txn
   * @param {http.ServerResponse} res
   * @param {Function} next
   * @api public
   */
  function response(txn, res, complete, next) {
    var mode = &#x27;query&#x27;
      , respond;
    if (txn.req &#x26;&#x26; txn.req.responseMode) {
      mode = txn.req.responseMode;
    }
    respond = modes[mode];

    if (!respond) {
      // http://lists.openid.net/pipermail/openid-specs-ab/Week-of-Mon-20140317/004680.html
      return next(new AuthorizationError(&#x27;Unsupported response mode: &#x27; + mode, &#x27;unsupported_response_mode&#x27;, null, 501));
    }
    if (respond &#x26;&#x26; respond.validate) {
      try {
        respond.validate(txn);
      } catch(ex) {
        return next(ex);
      }
    }

    if (!txn.res.allow) {
      var params = { error: &#x27;access_denied&#x27; };
      if (txn.req &#x26;&#x26; txn.req.state) { params.state = txn.req.state; }
      return respond(txn, res, params);
    }

    function issued(err, code) {
      if (err) { return next(err); }
      if (!code) { return next(new AuthorizationError(&#x27;Request denied by authorization server&#x27;, &#x27;access_denied&#x27;)); }

      var params = { code: code };
      if (txn.req &#x26;&#x26; txn.req.state) { params.state = txn.req.state; }
      complete(function(err) {
        if (err) { return next(err); }
        return respond(txn, res, params);
      });
    }

    // NOTE: The `redirect_uri`, if present in the client&#x27;s authorization
    //       request, must also be present in the subsequent request to exchange
    //       the authorization code for an access token.  Acting as a verifier,
    //       the two values must be equal and serve to protect against certain
    //       types of attacks.  More information can be found here:
    //
    //       http://hueniverse.com/2011/06/oauth-2-0-redirection-uri-validation/

    try {
      var arity = issue.length;
      if (arity == 7) {
        issue(txn.client, txn ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### Register Grants

A client must obtain permission from a user before it is issued an access token.
This permission is known as a grant, the most common type of which is an
authorization code.
```javascript
server.grant(oauth2orize.grant.<span class="apidocCodeKeywordSpan">code</span>(function(client, redirectURI, user, ares, done) {
var code = utils.uid(16);

var ac = new AuthorizationCode(code, client.id, redirectURI, user.id, ares.scope);
ac.save(function(err) {
  if (err) { return done(err); }
  return done(null, code);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.grant.implicit" id="apidoc.element.oauth2orize.grant.implicit">
        function <span class="apidocSignatureSpan">oauth2orize.grant.</span>implicit
        <span class="apidocSignatureSpan">(options, issue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function token(options, issue) {
  if (typeof options == &#x27;function&#x27;) {
    issue = options;
    options = undefined;
  }
  options = options || {};

  if (!issue) { throw new TypeError(&#x27;oauth2orize.token grant requires an issue callback&#x27;); }

  var modes = options.modes || {};
  if (!modes.fragment) {
    modes.fragment = require(&#x27;../response/fragment&#x27;);
  }

  // For maximum flexibility, multiple scope spearators can optionally be
  // allowed.  This allows the server to accept clients that separate scope
  // with either space or comma (&#x27; &#x27;, &#x27;,&#x27;).  This violates the specification,
  // but achieves compatibility with existing client libraries that are already
  // deployed.
  var separators = options.scopeSeparator || &#x27; &#x27;;
  if (!Array.isArray(separators)) {
    separators = [ separators ];
  }


<span class="apidocCodeCommentSpan">  /* Parse requests that request `token` as `response_type`.
   *
   * @param {http.ServerRequest} req
   * @api public
   */
</span>  function request(req) {
    var clientID = req.query.client_id
      , redirectURI = req.query.redirect_uri
      , scope = req.query.scope
      , state = req.query.state;

    if (!clientID) { throw new AuthorizationError(&#x27;Missing required parameter: client_id&#x27;, &#x27;invalid_request&#x27;); }
    if (typeof clientID !== &#x27;string&#x27;) { throw new AuthorizationError(&#x27;Invalid parameter: client_id must be a string&#x27;, &#x27;invalid_request
&#x27;); }

    if (scope) {
      if (typeof scope !== &#x27;string&#x27;) {
        throw new AuthorizationError(&#x27;Invalid parameter: scope must be a string&#x27;, &#x27;invalid_request&#x27;);
      }

      for (var i = 0, len = separators.length; i &#x3c; len; i++) {
        var separated = scope.split(separators[i]);
        // only separate on the first matching separator.  this allows for a sort
        // of separator &#x22;priority&#x22; (ie, favor spaces then fallback to commas)
        if (separated.length &#x3e; 1) {
          scope = separated;
          break;
        }
      }

      if (!Array.isArray(scope)) { scope = [ scope ]; }
    }

    return {
      clientID: clientID,
      redirectURI: redirectURI,
      scope: scope,
      state: state
    };
  }

  /* Sends responses to transactions that request `token` as `response_type`.
   *
   * @param {Object} txn
   * @param {http.ServerResponse} res
   * @param {Function} next
   * @api public
   */
  function response(txn, res, complete, next) {
    var mode = &#x27;fragment&#x27;
      , respond;
    if (txn.req &#x26;&#x26; txn.req.responseMode) {
      mode = txn.req.responseMode;
    }
    respond = modes[mode];

    if (!respond) {
      // http://lists.openid.net/pipermail/openid-specs-ab/Week-of-Mon-20140317/004680.html
      return next(new AuthorizationError(&#x27;Unsupported response mode: &#x27; + mode, &#x27;unsupported_response_mode&#x27;, null, 501));
    }
    if (respond &#x26;&#x26; respond.validate) {
      try {
        respond.validate(txn);
      } catch(ex) {
        return next(ex);
      }
    }

    if (!txn.res.allow) {
      var params = { error: &#x27;access_denied&#x27; };
      if (txn.req &#x26;&#x26; txn.req.state) { params.state = txn.req.state; }
      return respond(txn, res, params);
    }

    function issued(err, accessToken, params) {
      if (err) { return next(err); }
      if (!accessToken) { return next(new AuthorizationError(&#x27;Request denied by authorization server&#x27;, &#x27;access_denied&#x27;)); }

      var tok = {};
      tok.access_token = accessToken;
      if (params) { utils.merge(tok, params); }
      tok.token_type = tok.token_type || &#x27;Bearer&#x27;;
      if (txn.req &#x26;&#x26; txn.req.state) { tok.state = txn.req.state; }
      complete(function(err) {
        if (err) { return next(err); }
        return respond(txn, res, tok);
      });
    }

    // NOTE: In contrast to an authorization code grant, redirectURI is not
    //       passed as an argument to the issue callback because it is not used
    //       as a verifier in a subsequent token exchange.  However, when
    //       issuing an implicit access tokens, an application must ensure that
    //       the redirection URI is registered, which can be done in the
    //       `validate` callback ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.grant.token" id="apidoc.element.oauth2orize.grant.token">
        function <span class="apidocSignatureSpan">oauth2orize.grant.</span>token
        <span class="apidocSignatureSpan">(options, issue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function token(options, issue) {
  if (typeof options == &#x27;function&#x27;) {
    issue = options;
    options = undefined;
  }
  options = options || {};

  if (!issue) { throw new TypeError(&#x27;oauth2orize.token grant requires an issue callback&#x27;); }

  var modes = options.modes || {};
  if (!modes.fragment) {
    modes.fragment = require(&#x27;../response/fragment&#x27;);
  }

  // For maximum flexibility, multiple scope spearators can optionally be
  // allowed.  This allows the server to accept clients that separate scope
  // with either space or comma (&#x27; &#x27;, &#x27;,&#x27;).  This violates the specification,
  // but achieves compatibility with existing client libraries that are already
  // deployed.
  var separators = options.scopeSeparator || &#x27; &#x27;;
  if (!Array.isArray(separators)) {
    separators = [ separators ];
  }


<span class="apidocCodeCommentSpan">  /* Parse requests that request `token` as `response_type`.
   *
   * @param {http.ServerRequest} req
   * @api public
   */
</span>  function request(req) {
    var clientID = req.query.client_id
      , redirectURI = req.query.redirect_uri
      , scope = req.query.scope
      , state = req.query.state;

    if (!clientID) { throw new AuthorizationError(&#x27;Missing required parameter: client_id&#x27;, &#x27;invalid_request&#x27;); }
    if (typeof clientID !== &#x27;string&#x27;) { throw new AuthorizationError(&#x27;Invalid parameter: client_id must be a string&#x27;, &#x27;invalid_request
&#x27;); }

    if (scope) {
      if (typeof scope !== &#x27;string&#x27;) {
        throw new AuthorizationError(&#x27;Invalid parameter: scope must be a string&#x27;, &#x27;invalid_request&#x27;);
      }

      for (var i = 0, len = separators.length; i &#x3c; len; i++) {
        var separated = scope.split(separators[i]);
        // only separate on the first matching separator.  this allows for a sort
        // of separator &#x22;priority&#x22; (ie, favor spaces then fallback to commas)
        if (separated.length &#x3e; 1) {
          scope = separated;
          break;
        }
      }

      if (!Array.isArray(scope)) { scope = [ scope ]; }
    }

    return {
      clientID: clientID,
      redirectURI: redirectURI,
      scope: scope,
      state: state
    };
  }

  /* Sends responses to transactions that request `token` as `response_type`.
   *
   * @param {Object} txn
   * @param {http.ServerResponse} res
   * @param {Function} next
   * @api public
   */
  function response(txn, res, complete, next) {
    var mode = &#x27;fragment&#x27;
      , respond;
    if (txn.req &#x26;&#x26; txn.req.responseMode) {
      mode = txn.req.responseMode;
    }
    respond = modes[mode];

    if (!respond) {
      // http://lists.openid.net/pipermail/openid-specs-ab/Week-of-Mon-20140317/004680.html
      return next(new AuthorizationError(&#x27;Unsupported response mode: &#x27; + mode, &#x27;unsupported_response_mode&#x27;, null, 501));
    }
    if (respond &#x26;&#x26; respond.validate) {
      try {
        respond.validate(txn);
      } catch(ex) {
        return next(ex);
      }
    }

    if (!txn.res.allow) {
      var params = { error: &#x27;access_denied&#x27; };
      if (txn.req &#x26;&#x26; txn.req.state) { params.state = txn.req.state; }
      return respond(txn, res, params);
    }

    function issued(err, accessToken, params) {
      if (err) { return next(err); }
      if (!accessToken) { return next(new AuthorizationError(&#x27;Request denied by authorization server&#x27;, &#x27;access_denied&#x27;)); }

      var tok = {};
      tok.access_token = accessToken;
      if (params) { utils.merge(tok, params); }
      tok.token_type = tok.token_type || &#x27;Bearer&#x27;;
      if (txn.req &#x26;&#x26; txn.req.state) { tok.state = txn.req.state; }
      complete(function(err) {
        if (err) { return next(err); }
        return respond(txn, res, tok);
      });
    }

    // NOTE: In contrast to an authorization code grant, redirectURI is not
    //       passed as an argument to the issue callback because it is not used
    //       as a verifier in a subsequent token exchange.  However, when
    //       issuing an implicit access tokens, an application must ensure that
    //       the redirection URI is registered, which can be done in the
    //       `validate` callback ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Once a user has approved access, the authorization grant can be exchanged by the
client for an access token.

```javascript
app.post(&#x27;/token&#x27;,
  passport.authenticate([&#x27;basic&#x27;, &#x27;oauth2-client-password&#x27;], { session: false }),
  server.<span class="apidocCodeKeywordSpan">token</span>(),
  server.errorHandler());
```

[Passport](http://passportjs.org/) strategies are used to authenticate the
client, in this case using either an HTTP Basic authentication header (as
provided by [passport-http](https://github.com/jaredhanson/passport-http)) or
client credentials in the request body (as provided by
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
