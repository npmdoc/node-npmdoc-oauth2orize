<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/jaredhanson/oauth2orize#readme"

    >oauth2orize (v1.8.0)</a>
</h1>
<h4>OAuth 2.0 authorization server toolkit for Node.js.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.oauth2orize">module oauth2orize</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.AuthorizationError">
            function <span class="apidocSignatureSpan">oauth2orize.</span>AuthorizationError
            <span class="apidocSignatureSpan">(message, code, uri, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.OAuth2Error">
            function <span class="apidocSignatureSpan">oauth2orize.</span>OAuth2Error
            <span class="apidocSignatureSpan">(message, code, uri, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.TokenError">
            function <span class="apidocSignatureSpan">oauth2orize.</span>TokenError
            <span class="apidocSignatureSpan">(message, code, uri, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.createServer">
            function <span class="apidocSignatureSpan">oauth2orize.</span>createServer
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.errorHandler">
            function <span class="apidocSignatureSpan">oauth2orize.</span>errorHandler
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.server">
            function <span class="apidocSignatureSpan">oauth2orize.</span>server
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.unorderedlist">
            function <span class="apidocSignatureSpan">oauth2orize.</span>unorderedlist
            <span class="apidocSignatureSpan">(items)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">oauth2orize.</span>exchange</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">oauth2orize.</span>grant</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">oauth2orize.</span>server.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">oauth2orize.</span>unorderedlist.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">oauth2orize.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.oauth2orize.exchange">module oauth2orize.exchange</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.exchange.authorizationCode">
            function <span class="apidocSignatureSpan">oauth2orize.exchange.</span>authorizationCode
            <span class="apidocSignatureSpan">(options, issue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.exchange.clientCredentials">
            function <span class="apidocSignatureSpan">oauth2orize.exchange.</span>clientCredentials
            <span class="apidocSignatureSpan">(options, issue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.exchange.code">
            function <span class="apidocSignatureSpan">oauth2orize.exchange.</span>code
            <span class="apidocSignatureSpan">(options, issue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.exchange.password">
            function <span class="apidocSignatureSpan">oauth2orize.exchange.</span>password
            <span class="apidocSignatureSpan">(options, issue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.exchange.refreshToken">
            function <span class="apidocSignatureSpan">oauth2orize.exchange.</span>refreshToken
            <span class="apidocSignatureSpan">(options, issue)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.oauth2orize.grant">module oauth2orize.grant</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.grant.authorizationCode">
            function <span class="apidocSignatureSpan">oauth2orize.grant.</span>authorizationCode
            <span class="apidocSignatureSpan">(options, issue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.grant.code">
            function <span class="apidocSignatureSpan">oauth2orize.grant.</span>code
            <span class="apidocSignatureSpan">(options, issue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.grant.implicit">
            function <span class="apidocSignatureSpan">oauth2orize.grant.</span>implicit
            <span class="apidocSignatureSpan">(options, issue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.grant.token">
            function <span class="apidocSignatureSpan">oauth2orize.grant.</span>token
            <span class="apidocSignatureSpan">(options, issue)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.oauth2orize.server">module oauth2orize.server</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.server.server">
            function <span class="apidocSignatureSpan">oauth2orize.</span>server
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.oauth2orize.server.prototype">module oauth2orize.server.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.server.prototype._exchange">
            function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>_exchange
            <span class="apidocSignatureSpan">(type, req, res, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.server.prototype._parse">
            function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>_parse
            <span class="apidocSignatureSpan">(type, req, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.server.prototype._respond">
            function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>_respond
            <span class="apidocSignatureSpan">(txn, res, complete, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.server.prototype._respondError">
            function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>_respondError
            <span class="apidocSignatureSpan">(err, txn, res, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.server.prototype.authorization">
            function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>authorization
            <span class="apidocSignatureSpan">(options, validate, immediate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.server.prototype.authorizationError">
            function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>authorizationError
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.server.prototype.authorizationErrorHandler">
            function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>authorizationErrorHandler
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.server.prototype.authorize">
            function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>authorize
            <span class="apidocSignatureSpan">(options, validate, immediate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.server.prototype.authorizeError">
            function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>authorizeError
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.server.prototype.decision">
            function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>decision
            <span class="apidocSignatureSpan">(options, parse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.server.prototype.deserializeClient">
            function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>deserializeClient
            <span class="apidocSignatureSpan">(fn, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.server.prototype.errorHandler">
            function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>errorHandler
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.server.prototype.exchange">
            function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>exchange
            <span class="apidocSignatureSpan">(type, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.server.prototype.grant">
            function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>grant
            <span class="apidocSignatureSpan">(type, phase, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.server.prototype.resume">
            function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>resume
            <span class="apidocSignatureSpan">(options, immediate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.server.prototype.serializeClient">
            function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>serializeClient
            <span class="apidocSignatureSpan">(fn, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.server.prototype.token">
            function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>token
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.oauth2orize.unorderedlist">module oauth2orize.unorderedlist</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.unorderedlist.unorderedlist">
            function <span class="apidocSignatureSpan">oauth2orize.</span>unorderedlist
            <span class="apidocSignatureSpan">(items)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.oauth2orize.unorderedlist.prototype">module oauth2orize.unorderedlist.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.unorderedlist.prototype._length">
            function <span class="apidocSignatureSpan">oauth2orize.unorderedlist.prototype.</span>_length
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.unorderedlist.prototype.contains">
            function <span class="apidocSignatureSpan">oauth2orize.unorderedlist.prototype.</span>contains
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.unorderedlist.prototype.containsAny">
            function <span class="apidocSignatureSpan">oauth2orize.unorderedlist.prototype.</span>containsAny
            <span class="apidocSignatureSpan">(arr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.unorderedlist.prototype.equalTo">
            function <span class="apidocSignatureSpan">oauth2orize.unorderedlist.prototype.</span>equalTo
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.unorderedlist.prototype.toString">
            function <span class="apidocSignatureSpan">oauth2orize.unorderedlist.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.oauth2orize.utils">module oauth2orize.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.utils.merge">
            function <span class="apidocSignatureSpan">oauth2orize.utils.</span>merge
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.oauth2orize.utils.uid">
            function <span class="apidocSignatureSpan">oauth2orize.utils.</span>uid
            <span class="apidocSignatureSpan">(length, cb)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.oauth2orize" id="apidoc.module.oauth2orize">module oauth2orize</a></h1>


    <h2>
        <a href="#apidoc.element.oauth2orize.AuthorizationError" id="apidoc.element.oauth2orize.AuthorizationError">
        function <span class="apidocSignatureSpan">oauth2orize.</span>AuthorizationError
        <span class="apidocSignatureSpan">(message, code, uri, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AuthorizationError(message, code, uri, status) {
  if (!status) {
    switch (code) {
      case &#x27;invalid_request&#x27;: status = 400; break;
      case &#x27;unauthorized_client&#x27;: status = 403; break;
      case &#x27;access_denied&#x27;: status = 403; break;
      case &#x27;unsupported_response_type&#x27;: status = 501; break;
      case &#x27;invalid_scope&#x27;: status = 400; break;
      case &#x27;temporarily_unavailable&#x27;: status = 503; break;
    }
  }

  OAuth2Error.call(this, message, code, uri, status);
  Error.captureStackTrace(this, arguments.callee);
  this.name = &#x27;AuthorizationError&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.OAuth2Error" id="apidoc.element.oauth2orize.OAuth2Error">
        function <span class="apidocSignatureSpan">oauth2orize.</span>OAuth2Error
        <span class="apidocSignatureSpan">(message, code, uri, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OAuth2Error(message, code, uri, status) {
  Error.call(this);
  this.message = message;
  this.code = code || &#x27;server_error&#x27;;
  this.uri = uri;
  this.status = status || 500;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.TokenError" id="apidoc.element.oauth2orize.TokenError">
        function <span class="apidocSignatureSpan">oauth2orize.</span>TokenError
        <span class="apidocSignatureSpan">(message, code, uri, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TokenError(message, code, uri, status) {
  if (!status) {
    switch (code) {
      case &#x27;invalid_request&#x27;: status = 400; break;
      case &#x27;invalid_client&#x27;: status = 401; break;
      case &#x27;invalid_grant&#x27;: status = 403; break;
      case &#x27;unauthorized_client&#x27;: status = 403; break;
      case &#x27;unsupported_grant_type&#x27;: status = 501; break;
      case &#x27;invalid_scope&#x27;: status = 400; break;
    }
  }

  OAuth2Error.call(this, message, code, uri, status);
  Error.captureStackTrace(this, arguments.callee);
  this.name = &#x27;TokenError&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.createServer" id="apidoc.element.oauth2orize.createServer">
        function <span class="apidocSignatureSpan">oauth2orize.</span>createServer
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createServer(options) {
  var server = new Server(options);
  return server;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### Create an OAuth Server

Call `createServer()` to create a new OAuth 2.0 server.  This instance exposes
middleware that will be mounted in routes, as well as configuration options.

```javascript
var server = oauth2orize.<span class="apidocCodeKeywordSpan">createServer</span>();
```

#### Register Grants

A client must obtain permission from a user before it is issued an access token.
This permission is known as a grant, the most common type of which is an
authorization code.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.errorHandler" id="apidoc.element.oauth2orize.errorHandler">
        function <span class="apidocSignatureSpan">oauth2orize.</span>errorHandler
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">errorHandler = function (options) {
  options = options || {};

  var mode = options.mode || &#x27;direct&#x27;
    , fragment = options.fragment || [&#x27;token&#x27;]
    , modes = options.modes || {};

  if (!modes.query) {
    modes.query = require(&#x27;../response/query&#x27;);
  }
  if (!modes.fragment) {
    modes.fragment = require(&#x27;../response/fragment&#x27;);
  }

  return function errorHandler(err, req, res, next) {
    if (mode == &#x27;direct&#x27;) {
      if (err.status) { res.statusCode = err.status; }
      if (!res.statusCode || res.statusCode &#x3c; 400) { res.statusCode = 500; }

      if (res.statusCode == 401) {
        // TODO: set WWW-Authenticate header
      }

      var e = {};
      e.error = err.code || &#x27;server_error&#x27;;
      if (err.message) { e.error_description = err.message; }
      if (err.uri) { e.error_uri = err.uri; }

      res.setHeader(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;);
      return res.end(JSON.stringify(e));
    } else if (mode == &#x27;indirect&#x27;) {
      // If the redirectURI for this OAuth 2.0 transaction is invalid, the user
      // agent will not be redirected and the client will not be informed.  `next`
      // immediately into the application&#x27;s error handler, so a message can be
      // displayed to the user.
      if (!req.oauth2 || !req.oauth2.redirectURI) { return next(err); }

      var enc = &#x27;query&#x27;;
      if (req.oauth2.req) {
        var type = new UnorderedList(req.oauth2.req.type);
        // In accordance with [OAuth 2.0 Multiple Response Type Encoding
        // Practices - draft 08](http://openid.net/specs/oauth-v2-multiple-response-types-1_0.html),
        // if the response type contains any value that requires fragment
        // encoding, the response will be fragment encoded.
        if (type.containsAny(fragment)) { enc = &#x27;fragment&#x27;; }
        if (req.oauth2.req.responseMode) {
          // Encode the response using the requested mode, if specified.
          enc = req.oauth2.req.responseMode;
        }
      }

      var respond = modes[enc]
        , params = {};

      if (!respond) { return next(err); }

      params.error = err.code || &#x27;server_error&#x27;;
      if (err.message) { params.error_description = err.message; }
      if (err.uri) { params.error_uri = err.uri; }
      if (req.oauth2.req &#x26;&#x26; req.oauth2.req.state) { params.state = req.oauth2.req.state; }
      return respond(req.oauth2, res, params);
    } else {
      return next(err);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Once a user has approved access, the authorization grant can be exchanged by the
client for an access token.

```javascript
app.post(&#x27;/token&#x27;,
  passport.authenticate([&#x27;basic&#x27;, &#x27;oauth2-client-password&#x27;], { session: false }),
  server.token(),
  server.<span class="apidocCodeKeywordSpan">errorHandler</span>());
```

[Passport](http://passportjs.org/) strategies are used to authenticate the
client, in this case using either an HTTP Basic authentication header (as
provided by [passport-http](https://github.com/jaredhanson/passport-http)) or
client credentials in the request body (as provided by
[passport-oauth2-client-password](https://github.com/jaredhanson/passport-oauth2-client-password)).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.server" id="apidoc.element.oauth2orize.server">
        function <span class="apidocSignatureSpan">oauth2orize.</span>server
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Server(options) {
  options = options || {};
  this._reqParsers = [];
  this._resHandlers = [];
  this._errHandlers = [];
  this._exchanges = [];

  this._serializers = [];
  this._deserializers = [];
  this._txnStore = options.store || new SessionStore();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.unorderedlist" id="apidoc.element.oauth2orize.unorderedlist">
        function <span class="apidocSignatureSpan">oauth2orize.</span>unorderedlist
        <span class="apidocSignatureSpan">(items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function UnorderedList(items) {
  if (typeof items == &#x27;string&#x27;) {
    items = items.split(&#x27; &#x27;);
  }
  this._items = items || [];
  this.__defineGetter__(&#x27;length&#x27;, this._length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.oauth2orize.exchange" id="apidoc.module.oauth2orize.exchange">module oauth2orize.exchange</a></h1>


    <h2>
        <a href="#apidoc.element.oauth2orize.exchange.authorizationCode" id="apidoc.element.oauth2orize.exchange.authorizationCode">
        function <span class="apidocSignatureSpan">oauth2orize.exchange.</span>authorizationCode
        <span class="apidocSignatureSpan">(options, issue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authorizationCode = function (options, issue) {
  if (typeof options == &#x27;function&#x27;) {
    issue = options;
    options = undefined;
  }
  options = options || {};

  if (!issue) { throw new TypeError(&#x27;oauth2orize.authorizationCode exchange requires an issue callback&#x27;); }

  var userProperty = options.userProperty || &#x27;user&#x27;;

  return function authorization_code(req, res, next) {
    if (!req.body) { return next(new Error(&#x27;OAuth2orize requires body parsing. Did you forget app.use(express.bodyParser())?&#x27;)); }

    // The &#x27;user&#x27; property of `req` holds the authenticated user.  In the case
    // of the token endpoint, the property will contain the OAuth 2.0 client.
    var client = req[userProperty]
      , code = req.body.code
      , redirectURI = req.body.redirect_uri;

    if (!code) { return next(new TokenError(&#x27;Missing required parameter: code&#x27;, &#x27;invalid_request&#x27;)); }

    function issued(err, accessToken, refreshToken, params) {
      if (err) { return next(err); }
      if (!accessToken) { return next(new TokenError(&#x27;Invalid authorization code&#x27;, &#x27;invalid_grant&#x27;)); }
      if (refreshToken &#x26;&#x26; typeof refreshToken == &#x27;object&#x27;) {
        params = refreshToken;
        refreshToken = null;
      }

      var tok = {};
      tok.access_token = accessToken;
      if (refreshToken) { tok.refresh_token = refreshToken; }
      if (params) { utils.merge(tok, params); }
      tok.token_type = tok.token_type || &#x27;Bearer&#x27;;

      var json = JSON.stringify(tok);
      res.setHeader(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;);
      res.setHeader(&#x27;Cache-Control&#x27;, &#x27;no-store&#x27;);
      res.setHeader(&#x27;Pragma&#x27;, &#x27;no-cache&#x27;);
      res.end(json);
    }

    try {
      var arity = issue.length;
      if (arity == 6) {
        issue(client, code, redirectURI, req.body, req.authInfo, issued);
      } else if (arity == 5) {
        issue(client, code, redirectURI, req.body, issued);
      } else { // arity == 4
        issue(client, code, redirectURI, issued);
      }
    } catch (ex) {
      return next(ex);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* OAuth 2.0 defines an authorization framework, in which authorization grants
* can be of a variety of types.  Exchanging of these types for access tokens is
* implemented by exchange middleware, and the server registers the middleware
* it wishes to support.
*
* Examples:
*
*     server.exchange(oauth2orize.exchange.<span class="apidocCodeKeywordSpan">authorizationCode</span>(function() {
*       ...
*     }));
*
* @param {String|Function} type
* @param {Function} fn
* @return {Server} for chaining
* @api public
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.exchange.clientCredentials" id="apidoc.element.oauth2orize.exchange.clientCredentials">
        function <span class="apidocSignatureSpan">oauth2orize.exchange.</span>clientCredentials
        <span class="apidocSignatureSpan">(options, issue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clientCredentials = function (options, issue) {
  if (typeof options == &#x27;function&#x27;) {
    issue = options;
    options = undefined;
  }
  options = options || {};

  if (!issue) { throw new TypeError(&#x27;oauth2orize.clientCredentials exchange requires an issue callback&#x27;); }

  var userProperty = options.userProperty || &#x27;user&#x27;;

  // For maximum flexibility, multiple scope spearators can optionally be
  // allowed.  This allows the server to accept clients that separate scope
  // with either space or comma (&#x27; &#x27;, &#x27;,&#x27;).  This violates the specification,
  // but achieves compatibility with existing client libraries that are already
  // deployed.
  var separators = options.scopeSeparator || &#x27; &#x27;;
  if (!Array.isArray(separators)) {
    separators = [ separators ];
  }

  return function client_credentials(req, res, next) {
    if (!req.body) { return next(new Error(&#x27;OAuth2orize requires body parsing. Did you forget app.use(express.bodyParser())?&#x27;)); }

    // The &#x27;user&#x27; property of `req` holds the authenticated user.  In the case
    // of the token endpoint, the property will contain the OAuth 2.0 client.
    var client = req[userProperty]
      , scope = req.body.scope;

    if (scope) {
      for (var i = 0, len = separators.length; i &#x3c; len; i++) {
        var separated = scope.split(separators[i]);
        // only separate on the first matching separator.  this allows for a sort
        // of separator &#x22;priority&#x22; (ie, favor spaces then fallback to commas)
        if (separated.length &#x3e; 1) {
          scope = separated;
          break;
        }
      }
      if (!Array.isArray(scope)) { scope = [ scope ]; }
    }

    function issued(err, accessToken, refreshToken, params) {
      if (err) { return next(err); }
      if (!accessToken) { return next(new TokenError(&#x27;Invalid client credentials&#x27;, &#x27;invalid_grant&#x27;)); }
      if (refreshToken &#x26;&#x26; typeof refreshToken == &#x27;object&#x27;) {
        params = refreshToken;
        refreshToken = null;
      }

      var tok = {};
      tok.access_token = accessToken;
      if (refreshToken) { tok.refresh_token = refreshToken; }
      if (params) { utils.merge(tok, params); }
      tok.token_type = tok.token_type || &#x27;Bearer&#x27;;

      var json = JSON.stringify(tok);
      res.setHeader(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;);
      res.setHeader(&#x27;Cache-Control&#x27;, &#x27;no-store&#x27;);
      res.setHeader(&#x27;Pragma&#x27;, &#x27;no-cache&#x27;);
      res.end(json);
    }

    try {
      var arity = issue.length;
      if (arity == 5) {
        issue(client, scope, req.body, req.authInfo, issued);
      } else if (arity == 4) {
        issue(client, scope, req.body, issued);
      } else if (arity == 3) {
        issue(client, scope, issued);
      } else { // arity == 2
        issue(client, issued);
      }
    } catch (ex) {
      return next(ex);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.exchange.code" id="apidoc.element.oauth2orize.exchange.code">
        function <span class="apidocSignatureSpan">oauth2orize.exchange.</span>code
        <span class="apidocSignatureSpan">(options, issue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">code = function (options, issue) {
  if (typeof options == &#x27;function&#x27;) {
    issue = options;
    options = undefined;
  }
  options = options || {};

  if (!issue) { throw new TypeError(&#x27;oauth2orize.authorizationCode exchange requires an issue callback&#x27;); }

  var userProperty = options.userProperty || &#x27;user&#x27;;

  return function authorization_code(req, res, next) {
    if (!req.body) { return next(new Error(&#x27;OAuth2orize requires body parsing. Did you forget app.use(express.bodyParser())?&#x27;)); }

    // The &#x27;user&#x27; property of `req` holds the authenticated user.  In the case
    // of the token endpoint, the property will contain the OAuth 2.0 client.
    var client = req[userProperty]
      , code = req.body.code
      , redirectURI = req.body.redirect_uri;

    if (!code) { return next(new TokenError(&#x27;Missing required parameter: code&#x27;, &#x27;invalid_request&#x27;)); }

    function issued(err, accessToken, refreshToken, params) {
      if (err) { return next(err); }
      if (!accessToken) { return next(new TokenError(&#x27;Invalid authorization code&#x27;, &#x27;invalid_grant&#x27;)); }
      if (refreshToken &#x26;&#x26; typeof refreshToken == &#x27;object&#x27;) {
        params = refreshToken;
        refreshToken = null;
      }

      var tok = {};
      tok.access_token = accessToken;
      if (refreshToken) { tok.refresh_token = refreshToken; }
      if (params) { utils.merge(tok, params); }
      tok.token_type = tok.token_type || &#x27;Bearer&#x27;;

      var json = JSON.stringify(tok);
      res.setHeader(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;);
      res.setHeader(&#x27;Cache-Control&#x27;, &#x27;no-store&#x27;);
      res.setHeader(&#x27;Pragma&#x27;, &#x27;no-cache&#x27;);
      res.end(json);
    }

    try {
      var arity = issue.length;
      if (arity == 6) {
        issue(client, code, redirectURI, req.body, req.authInfo, issued);
      } else if (arity == 5) {
        issue(client, code, redirectURI, req.body, issued);
      } else { // arity == 4
        issue(client, code, redirectURI, issued);
      }
    } catch (ex) {
      return next(ex);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### Register Grants

A client must obtain permission from a user before it is issued an access token.
This permission is known as a grant, the most common type of which is an
authorization code.
```javascript
server.grant(oauth2orize.grant.<span class="apidocCodeKeywordSpan">code</span>(function(client, redirectURI, user, ares, done) {
var code = utils.uid(16);

var ac = new AuthorizationCode(code, client.id, redirectURI, user.id, ares.scope);
ac.save(function(err) {
  if (err) { return done(err); }
  return done(null, code);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.exchange.password" id="apidoc.element.oauth2orize.exchange.password">
        function <span class="apidocSignatureSpan">oauth2orize.exchange.</span>password
        <span class="apidocSignatureSpan">(options, issue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">password = function (options, issue) {
  if (typeof options == &#x27;function&#x27;) {
    issue = options;
    options = undefined;
  }
  options = options || {};

  if (!issue) { throw new TypeError(&#x27;oauth2orize.password exchange requires an issue callback&#x27;); }

  var userProperty = options.userProperty || &#x27;user&#x27;;

  // For maximum flexibility, multiple scope spearators can optionally be
  // allowed.  This allows the server to accept clients that separate scope
  // with either space or comma (&#x27; &#x27;, &#x27;,&#x27;).  This violates the specification,
  // but achieves compatibility with existing client libraries that are already
  // deployed.
  var separators = options.scopeSeparator || &#x27; &#x27;;
  if (!Array.isArray(separators)) {
    separators = [ separators ];
  }

  return function password(req, res, next) {
    if (!req.body) { return next(new Error(&#x27;OAuth2orize requires body parsing. Did you forget app.use(express.bodyParser())?&#x27;)); }

    // The &#x27;user&#x27; property of `req` holds the authenticated user.  In the case
    // of the token endpoint, the property will contain the OAuth 2.0 client.
    var client = req[userProperty]
      , username = req.body.username
      , passwd = req.body.password
      , scope = req.body.scope;

    if (!username) { return next(new TokenError(&#x27;Missing required parameter: username&#x27;, &#x27;invalid_request&#x27;)); }
    if (!passwd) { return next(new TokenError(&#x27;Missing required parameter: password&#x27;, &#x27;invalid_request&#x27;)); }

    if (scope) {
      for (var i = 0, len = separators.length; i &#x3c; len; i++) {
        var separated = scope.split(separators[i]);
        // only separate on the first matching separator.  this allows for a sort
        // of separator &#x22;priority&#x22; (ie, favor spaces then fallback to commas)
        if (separated.length &#x3e; 1) {
          scope = separated;
          break;
        }
      }
      if (!Array.isArray(scope)) { scope = [ scope ]; }
    }

    function issued(err, accessToken, refreshToken, params) {
      if (err) { return next(err); }
      if (!accessToken) { return next(new TokenError(&#x27;Invalid resource owner credentials&#x27;, &#x27;invalid_grant&#x27;)); }
      if (refreshToken &#x26;&#x26; typeof refreshToken == &#x27;object&#x27;) {
        params = refreshToken;
        refreshToken = null;
      }

      var tok = {};
      tok.access_token = accessToken;
      if (refreshToken) { tok.refresh_token = refreshToken; }
      if (params) { utils.merge(tok, params); }
      tok.token_type = tok.token_type || &#x27;Bearer&#x27;;

      var json = JSON.stringify(tok);
      res.setHeader(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;);
      res.setHeader(&#x27;Cache-Control&#x27;, &#x27;no-store&#x27;);
      res.setHeader(&#x27;Pragma&#x27;, &#x27;no-cache&#x27;);
      res.end(json);
    }

    try {
      var arity = issue.length;
      if (arity == 7) {
        issue(client, username, passwd, scope, req.body, req.authInfo, issued);
      } else if (arity == 6) {
        issue(client, username, passwd, scope, req.body, issued);
      } else if (arity == 5) {
        issue(client, username, passwd, scope, issued);
      } else { // arity == 4
        issue(client, username, passwd, issued);
      }
    } catch (ex) {
      return next(ex);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.exchange.refreshToken" id="apidoc.element.oauth2orize.exchange.refreshToken">
        function <span class="apidocSignatureSpan">oauth2orize.exchange.</span>refreshToken
        <span class="apidocSignatureSpan">(options, issue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">refreshToken = function (options, issue) {
  if (typeof options == &#x27;function&#x27;) {
    issue = options;
    options = undefined;
  }
  options = options || {};

  if (!issue) { throw new TypeError(&#x27;oauth2orize.refreshToken exchange requires an issue callback&#x27;); }

  var userProperty = options.userProperty || &#x27;user&#x27;;

  // For maximum flexibility, multiple scope spearators can optionally be
  // allowed.  This allows the server to accept clients that separate scope
  // with either space or comma (&#x27; &#x27;, &#x27;,&#x27;).  This violates the specification,
  // but achieves compatibility with existing client libraries that are already
  // deployed.
  var separators = options.scopeSeparator || &#x27; &#x27;;
  if (!Array.isArray(separators)) {
    separators = [ separators ];
  }

  return function refresh_token(req, res, next) {
    if (!req.body) { return next(new Error(&#x27;OAuth2orize requires body parsing. Did you forget app.use(express.bodyParser())?&#x27;)); }

    // The &#x27;user&#x27; property of `req` holds the authenticated user.  In the case
    // of the token endpoint, the property will contain the OAuth 2.0 client.
    var client = req[userProperty]
      , refreshToken = req.body.refresh_token
      , scope = req.body.scope;

    if (!refreshToken) { return next(new TokenError(&#x27;Missing required parameter: refresh_token&#x27;, &#x27;invalid_request&#x27;)); }

    if (scope) {
      for (var i = 0, len = separators.length; i &#x3c; len; i++) {
        var separated = scope.split(separators[i]);
        // only separate on the first matching separator.  this allows for a sort
        // of separator &#x22;priority&#x22; (ie, favor spaces then fallback to commas)
        if (separated.length &#x3e; 1) {
          scope = separated;
          break;
        }
      }
      if (!Array.isArray(scope)) { scope = [ scope ]; }
    }

    function issued(err, accessToken, refreshToken, params) {
      if (err) { return next(err); }
      if (!accessToken) { return next(new TokenError(&#x27;Invalid refresh token&#x27;, &#x27;invalid_grant&#x27;)); }
      if (refreshToken &#x26;&#x26; typeof refreshToken == &#x27;object&#x27;) {
        params = refreshToken;
        refreshToken = null;
      }

      var tok = {};
      tok.access_token = accessToken;
      if (refreshToken) { tok.refresh_token = refreshToken; }
      if (params) { utils.merge(tok, params); }
      tok.token_type = tok.token_type || &#x27;Bearer&#x27;;

      var json = JSON.stringify(tok);
      res.setHeader(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;);
      res.setHeader(&#x27;Cache-Control&#x27;, &#x27;no-store&#x27;);
      res.setHeader(&#x27;Pragma&#x27;, &#x27;no-cache&#x27;);
      res.end(json);
    }

    try {
      var arity = issue.length;
      if (arity == 6) {
        issue(client, refreshToken, scope, req.body, req.authInfo, issued);
      } else if (arity == 5) {
        issue(client, refreshToken, scope, req.body, issued);
      } else if (arity == 4) {
        issue(client, refreshToken, scope, issued);
      } else { // arity == 3
        issue(client, refreshToken, issued);
      }
    } catch (ex) {
      return next(ex);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.oauth2orize.grant" id="apidoc.module.oauth2orize.grant">module oauth2orize.grant</a></h1>


    <h2>
        <a href="#apidoc.element.oauth2orize.grant.authorizationCode" id="apidoc.element.oauth2orize.grant.authorizationCode">
        function <span class="apidocSignatureSpan">oauth2orize.grant.</span>authorizationCode
        <span class="apidocSignatureSpan">(options, issue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function code(options, issue) {
  if (typeof options == &#x27;function&#x27;) {
    issue = options;
    options = undefined;
  }
  options = options || {};

  if (!issue) { throw new TypeError(&#x27;oauth2orize.code grant requires an issue callback&#x27;); }

  var modes = options.modes || {};
  if (!modes.query) {
    modes.query = require(&#x27;../response/query&#x27;);
  }

  // For maximum flexibility, multiple scope spearators can optionally be
  // allowed.  This allows the server to accept clients that separate scope
  // with either space or comma (&#x27; &#x27;, &#x27;,&#x27;).  This violates the specification,
  // but achieves compatibility with existing client libraries that are already
  // deployed.
  var separators = options.scopeSeparator || &#x27; &#x27;;
  if (!Array.isArray(separators)) {
    separators = [ separators ];
  }


<span class="apidocCodeCommentSpan">  /* Parse requests that request `code` as `response_type`.
   *
   * @param {http.ServerRequest} req
   * @api public
   */
</span>  function request(req) {
    var clientID = req.query.client_id
      , redirectURI = req.query.redirect_uri
      , scope = req.query.scope
      , state = req.query.state;

    if (!clientID) { throw new AuthorizationError(&#x27;Missing required parameter: client_id&#x27;, &#x27;invalid_request&#x27;); }
    if (typeof clientID !== &#x27;string&#x27;) { throw new AuthorizationError(&#x27;Invalid parameter: client_id must be a string&#x27;, &#x27;invalid_request
&#x27;); }

    if (scope) {
      if (typeof scope !== &#x27;string&#x27;) {
        throw new AuthorizationError(&#x27;Invalid parameter: scope must be a string&#x27;, &#x27;invalid_request&#x27;);
      }

      for (var i = 0, len = separators.length; i &#x3c; len; i++) {
        var separated = scope.split(separators[i]);
        // only separate on the first matching separator.  this allows for a sort
        // of separator &#x22;priority&#x22; (ie, favor spaces then fallback to commas)
        if (separated.length &#x3e; 1) {
          scope = separated;
          break;
        }
      }

      if (!Array.isArray(scope)) { scope = [ scope ]; }
    }

    return {
      clientID: clientID,
      redirectURI: redirectURI,
      scope: scope,
      state: state
    };
  }

  /* Sends responses to transactions that request `code` as `response_type`.
   *
   * @param {Object} txn
   * @param {http.ServerResponse} res
   * @param {Function} next
   * @api public
   */
  function response(txn, res, complete, next) {
    var mode = &#x27;query&#x27;
      , respond;
    if (txn.req &#x26;&#x26; txn.req.responseMode) {
      mode = txn.req.responseMode;
    }
    respond = modes[mode];

    if (!respond) {
      // http://lists.openid.net/pipermail/openid-specs-ab/Week-of-Mon-20140317/004680.html
      return next(new AuthorizationError(&#x27;Unsupported response mode: &#x27; + mode, &#x27;unsupported_response_mode&#x27;, null, 501));
    }
    if (respond &#x26;&#x26; respond.validate) {
      try {
        respond.validate(txn);
      } catch(ex) {
        return next(ex);
      }
    }

    if (!txn.res.allow) {
      var params = { error: &#x27;access_denied&#x27; };
      if (txn.req &#x26;&#x26; txn.req.state) { params.state = txn.req.state; }
      return respond(txn, res, params);
    }

    function issued(err, code) {
      if (err) { return next(err); }
      if (!code) { return next(new AuthorizationError(&#x27;Request denied by authorization server&#x27;, &#x27;access_denied&#x27;)); }

      var params = { code: code };
      if (txn.req &#x26;&#x26; txn.req.state) { params.state = txn.req.state; }
      complete(function(err) {
        if (err) { return next(err); }
        return respond(txn, res, params);
      });
    }

    // NOTE: The `redirect_uri`, if present in the client&#x27;s authorization
    //       request, must also be present in the subsequent request to exchange
    //       the authorization code for an access token.  Acting as a verifier,
    //       the two values must be equal and serve to protect against certain
    //       types of attacks.  More information can be found here:
    //
    //       http://hueniverse.com/2011/06/oauth-2-0-redirection-uri-validation/

    try {
      var arity = issue.length;
      if (arity == 7) {
        issue(txn.client, txn ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* OAuth 2.0 defines an authorization framework, in which authorization grants
* can be of a variety of types.  Exchanging of these types for access tokens is
* implemented by exchange middleware, and the server registers the middleware
* it wishes to support.
*
* Examples:
*
*     server.exchange(oauth2orize.exchange.<span class="apidocCodeKeywordSpan">authorizationCode</span>(function() {
*       ...
*     }));
*
* @param {String|Function} type
* @param {Function} fn
* @return {Server} for chaining
* @api public
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.grant.code" id="apidoc.element.oauth2orize.grant.code">
        function <span class="apidocSignatureSpan">oauth2orize.grant.</span>code
        <span class="apidocSignatureSpan">(options, issue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function code(options, issue) {
  if (typeof options == &#x27;function&#x27;) {
    issue = options;
    options = undefined;
  }
  options = options || {};

  if (!issue) { throw new TypeError(&#x27;oauth2orize.code grant requires an issue callback&#x27;); }

  var modes = options.modes || {};
  if (!modes.query) {
    modes.query = require(&#x27;../response/query&#x27;);
  }

  // For maximum flexibility, multiple scope spearators can optionally be
  // allowed.  This allows the server to accept clients that separate scope
  // with either space or comma (&#x27; &#x27;, &#x27;,&#x27;).  This violates the specification,
  // but achieves compatibility with existing client libraries that are already
  // deployed.
  var separators = options.scopeSeparator || &#x27; &#x27;;
  if (!Array.isArray(separators)) {
    separators = [ separators ];
  }


<span class="apidocCodeCommentSpan">  /* Parse requests that request `code` as `response_type`.
   *
   * @param {http.ServerRequest} req
   * @api public
   */
</span>  function request(req) {
    var clientID = req.query.client_id
      , redirectURI = req.query.redirect_uri
      , scope = req.query.scope
      , state = req.query.state;

    if (!clientID) { throw new AuthorizationError(&#x27;Missing required parameter: client_id&#x27;, &#x27;invalid_request&#x27;); }
    if (typeof clientID !== &#x27;string&#x27;) { throw new AuthorizationError(&#x27;Invalid parameter: client_id must be a string&#x27;, &#x27;invalid_request
&#x27;); }

    if (scope) {
      if (typeof scope !== &#x27;string&#x27;) {
        throw new AuthorizationError(&#x27;Invalid parameter: scope must be a string&#x27;, &#x27;invalid_request&#x27;);
      }

      for (var i = 0, len = separators.length; i &#x3c; len; i++) {
        var separated = scope.split(separators[i]);
        // only separate on the first matching separator.  this allows for a sort
        // of separator &#x22;priority&#x22; (ie, favor spaces then fallback to commas)
        if (separated.length &#x3e; 1) {
          scope = separated;
          break;
        }
      }

      if (!Array.isArray(scope)) { scope = [ scope ]; }
    }

    return {
      clientID: clientID,
      redirectURI: redirectURI,
      scope: scope,
      state: state
    };
  }

  /* Sends responses to transactions that request `code` as `response_type`.
   *
   * @param {Object} txn
   * @param {http.ServerResponse} res
   * @param {Function} next
   * @api public
   */
  function response(txn, res, complete, next) {
    var mode = &#x27;query&#x27;
      , respond;
    if (txn.req &#x26;&#x26; txn.req.responseMode) {
      mode = txn.req.responseMode;
    }
    respond = modes[mode];

    if (!respond) {
      // http://lists.openid.net/pipermail/openid-specs-ab/Week-of-Mon-20140317/004680.html
      return next(new AuthorizationError(&#x27;Unsupported response mode: &#x27; + mode, &#x27;unsupported_response_mode&#x27;, null, 501));
    }
    if (respond &#x26;&#x26; respond.validate) {
      try {
        respond.validate(txn);
      } catch(ex) {
        return next(ex);
      }
    }

    if (!txn.res.allow) {
      var params = { error: &#x27;access_denied&#x27; };
      if (txn.req &#x26;&#x26; txn.req.state) { params.state = txn.req.state; }
      return respond(txn, res, params);
    }

    function issued(err, code) {
      if (err) { return next(err); }
      if (!code) { return next(new AuthorizationError(&#x27;Request denied by authorization server&#x27;, &#x27;access_denied&#x27;)); }

      var params = { code: code };
      if (txn.req &#x26;&#x26; txn.req.state) { params.state = txn.req.state; }
      complete(function(err) {
        if (err) { return next(err); }
        return respond(txn, res, params);
      });
    }

    // NOTE: The `redirect_uri`, if present in the client&#x27;s authorization
    //       request, must also be present in the subsequent request to exchange
    //       the authorization code for an access token.  Acting as a verifier,
    //       the two values must be equal and serve to protect against certain
    //       types of attacks.  More information can be found here:
    //
    //       http://hueniverse.com/2011/06/oauth-2-0-redirection-uri-validation/

    try {
      var arity = issue.length;
      if (arity == 7) {
        issue(txn.client, txn ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### Register Grants

A client must obtain permission from a user before it is issued an access token.
This permission is known as a grant, the most common type of which is an
authorization code.
```javascript
server.grant(oauth2orize.grant.<span class="apidocCodeKeywordSpan">code</span>(function(client, redirectURI, user, ares, done) {
var code = utils.uid(16);

var ac = new AuthorizationCode(code, client.id, redirectURI, user.id, ares.scope);
ac.save(function(err) {
  if (err) { return done(err); }
  return done(null, code);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.grant.implicit" id="apidoc.element.oauth2orize.grant.implicit">
        function <span class="apidocSignatureSpan">oauth2orize.grant.</span>implicit
        <span class="apidocSignatureSpan">(options, issue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function token(options, issue) {
  if (typeof options == &#x27;function&#x27;) {
    issue = options;
    options = undefined;
  }
  options = options || {};

  if (!issue) { throw new TypeError(&#x27;oauth2orize.token grant requires an issue callback&#x27;); }

  var modes = options.modes || {};
  if (!modes.fragment) {
    modes.fragment = require(&#x27;../response/fragment&#x27;);
  }

  // For maximum flexibility, multiple scope spearators can optionally be
  // allowed.  This allows the server to accept clients that separate scope
  // with either space or comma (&#x27; &#x27;, &#x27;,&#x27;).  This violates the specification,
  // but achieves compatibility with existing client libraries that are already
  // deployed.
  var separators = options.scopeSeparator || &#x27; &#x27;;
  if (!Array.isArray(separators)) {
    separators = [ separators ];
  }


<span class="apidocCodeCommentSpan">  /* Parse requests that request `token` as `response_type`.
   *
   * @param {http.ServerRequest} req
   * @api public
   */
</span>  function request(req) {
    var clientID = req.query.client_id
      , redirectURI = req.query.redirect_uri
      , scope = req.query.scope
      , state = req.query.state;

    if (!clientID) { throw new AuthorizationError(&#x27;Missing required parameter: client_id&#x27;, &#x27;invalid_request&#x27;); }
    if (typeof clientID !== &#x27;string&#x27;) { throw new AuthorizationError(&#x27;Invalid parameter: client_id must be a string&#x27;, &#x27;invalid_request
&#x27;); }

    if (scope) {
      if (typeof scope !== &#x27;string&#x27;) {
        throw new AuthorizationError(&#x27;Invalid parameter: scope must be a string&#x27;, &#x27;invalid_request&#x27;);
      }

      for (var i = 0, len = separators.length; i &#x3c; len; i++) {
        var separated = scope.split(separators[i]);
        // only separate on the first matching separator.  this allows for a sort
        // of separator &#x22;priority&#x22; (ie, favor spaces then fallback to commas)
        if (separated.length &#x3e; 1) {
          scope = separated;
          break;
        }
      }

      if (!Array.isArray(scope)) { scope = [ scope ]; }
    }

    return {
      clientID: clientID,
      redirectURI: redirectURI,
      scope: scope,
      state: state
    };
  }

  /* Sends responses to transactions that request `token` as `response_type`.
   *
   * @param {Object} txn
   * @param {http.ServerResponse} res
   * @param {Function} next
   * @api public
   */
  function response(txn, res, complete, next) {
    var mode = &#x27;fragment&#x27;
      , respond;
    if (txn.req &#x26;&#x26; txn.req.responseMode) {
      mode = txn.req.responseMode;
    }
    respond = modes[mode];

    if (!respond) {
      // http://lists.openid.net/pipermail/openid-specs-ab/Week-of-Mon-20140317/004680.html
      return next(new AuthorizationError(&#x27;Unsupported response mode: &#x27; + mode, &#x27;unsupported_response_mode&#x27;, null, 501));
    }
    if (respond &#x26;&#x26; respond.validate) {
      try {
        respond.validate(txn);
      } catch(ex) {
        return next(ex);
      }
    }

    if (!txn.res.allow) {
      var params = { error: &#x27;access_denied&#x27; };
      if (txn.req &#x26;&#x26; txn.req.state) { params.state = txn.req.state; }
      return respond(txn, res, params);
    }

    function issued(err, accessToken, params) {
      if (err) { return next(err); }
      if (!accessToken) { return next(new AuthorizationError(&#x27;Request denied by authorization server&#x27;, &#x27;access_denied&#x27;)); }

      var tok = {};
      tok.access_token = accessToken;
      if (params) { utils.merge(tok, params); }
      tok.token_type = tok.token_type || &#x27;Bearer&#x27;;
      if (txn.req &#x26;&#x26; txn.req.state) { tok.state = txn.req.state; }
      complete(function(err) {
        if (err) { return next(err); }
        return respond(txn, res, tok);
      });
    }

    // NOTE: In contrast to an authorization code grant, redirectURI is not
    //       passed as an argument to the issue callback because it is not used
    //       as a verifier in a subsequent token exchange.  However, when
    //       issuing an implicit access tokens, an application must ensure that
    //       the redirection URI is registered, which can be done in the
    //       `validate` callback ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.grant.token" id="apidoc.element.oauth2orize.grant.token">
        function <span class="apidocSignatureSpan">oauth2orize.grant.</span>token
        <span class="apidocSignatureSpan">(options, issue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function token(options, issue) {
  if (typeof options == &#x27;function&#x27;) {
    issue = options;
    options = undefined;
  }
  options = options || {};

  if (!issue) { throw new TypeError(&#x27;oauth2orize.token grant requires an issue callback&#x27;); }

  var modes = options.modes || {};
  if (!modes.fragment) {
    modes.fragment = require(&#x27;../response/fragment&#x27;);
  }

  // For maximum flexibility, multiple scope spearators can optionally be
  // allowed.  This allows the server to accept clients that separate scope
  // with either space or comma (&#x27; &#x27;, &#x27;,&#x27;).  This violates the specification,
  // but achieves compatibility with existing client libraries that are already
  // deployed.
  var separators = options.scopeSeparator || &#x27; &#x27;;
  if (!Array.isArray(separators)) {
    separators = [ separators ];
  }


<span class="apidocCodeCommentSpan">  /* Parse requests that request `token` as `response_type`.
   *
   * @param {http.ServerRequest} req
   * @api public
   */
</span>  function request(req) {
    var clientID = req.query.client_id
      , redirectURI = req.query.redirect_uri
      , scope = req.query.scope
      , state = req.query.state;

    if (!clientID) { throw new AuthorizationError(&#x27;Missing required parameter: client_id&#x27;, &#x27;invalid_request&#x27;); }
    if (typeof clientID !== &#x27;string&#x27;) { throw new AuthorizationError(&#x27;Invalid parameter: client_id must be a string&#x27;, &#x27;invalid_request
&#x27;); }

    if (scope) {
      if (typeof scope !== &#x27;string&#x27;) {
        throw new AuthorizationError(&#x27;Invalid parameter: scope must be a string&#x27;, &#x27;invalid_request&#x27;);
      }

      for (var i = 0, len = separators.length; i &#x3c; len; i++) {
        var separated = scope.split(separators[i]);
        // only separate on the first matching separator.  this allows for a sort
        // of separator &#x22;priority&#x22; (ie, favor spaces then fallback to commas)
        if (separated.length &#x3e; 1) {
          scope = separated;
          break;
        }
      }

      if (!Array.isArray(scope)) { scope = [ scope ]; }
    }

    return {
      clientID: clientID,
      redirectURI: redirectURI,
      scope: scope,
      state: state
    };
  }

  /* Sends responses to transactions that request `token` as `response_type`.
   *
   * @param {Object} txn
   * @param {http.ServerResponse} res
   * @param {Function} next
   * @api public
   */
  function response(txn, res, complete, next) {
    var mode = &#x27;fragment&#x27;
      , respond;
    if (txn.req &#x26;&#x26; txn.req.responseMode) {
      mode = txn.req.responseMode;
    }
    respond = modes[mode];

    if (!respond) {
      // http://lists.openid.net/pipermail/openid-specs-ab/Week-of-Mon-20140317/004680.html
      return next(new AuthorizationError(&#x27;Unsupported response mode: &#x27; + mode, &#x27;unsupported_response_mode&#x27;, null, 501));
    }
    if (respond &#x26;&#x26; respond.validate) {
      try {
        respond.validate(txn);
      } catch(ex) {
        return next(ex);
      }
    }

    if (!txn.res.allow) {
      var params = { error: &#x27;access_denied&#x27; };
      if (txn.req &#x26;&#x26; txn.req.state) { params.state = txn.req.state; }
      return respond(txn, res, params);
    }

    function issued(err, accessToken, params) {
      if (err) { return next(err); }
      if (!accessToken) { return next(new AuthorizationError(&#x27;Request denied by authorization server&#x27;, &#x27;access_denied&#x27;)); }

      var tok = {};
      tok.access_token = accessToken;
      if (params) { utils.merge(tok, params); }
      tok.token_type = tok.token_type || &#x27;Bearer&#x27;;
      if (txn.req &#x26;&#x26; txn.req.state) { tok.state = txn.req.state; }
      complete(function(err) {
        if (err) { return next(err); }
        return respond(txn, res, tok);
      });
    }

    // NOTE: In contrast to an authorization code grant, redirectURI is not
    //       passed as an argument to the issue callback because it is not used
    //       as a verifier in a subsequent token exchange.  However, when
    //       issuing an implicit access tokens, an application must ensure that
    //       the redirection URI is registered, which can be done in the
    //       `validate` callback ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Once a user has approved access, the authorization grant can be exchanged by the
client for an access token.

```javascript
app.post(&#x27;/token&#x27;,
  passport.authenticate([&#x27;basic&#x27;, &#x27;oauth2-client-password&#x27;], { session: false }),
  server.<span class="apidocCodeKeywordSpan">token</span>(),
  server.errorHandler());
```

[Passport](http://passportjs.org/) strategies are used to authenticate the
client, in this case using either an HTTP Basic authentication header (as
provided by [passport-http](https://github.com/jaredhanson/passport-http)) or
client credentials in the request body (as provided by
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.oauth2orize.server" id="apidoc.module.oauth2orize.server">module oauth2orize.server</a></h1>


    <h2>
        <a href="#apidoc.element.oauth2orize.server.server" id="apidoc.element.oauth2orize.server.server">
        function <span class="apidocSignatureSpan">oauth2orize.</span>server
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Server(options) {
  options = options || {};
  this._reqParsers = [];
  this._resHandlers = [];
  this._errHandlers = [];
  this._exchanges = [];

  this._serializers = [];
  this._deserializers = [];
  this._txnStore = options.store || new SessionStore();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.oauth2orize.server.prototype" id="apidoc.module.oauth2orize.server.prototype">module oauth2orize.server.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.oauth2orize.server.prototype._exchange" id="apidoc.element.oauth2orize.server.prototype._exchange">
        function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>_exchange
        <span class="apidocSignatureSpan">(type, req, res, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_exchange = function (type, req, res, cb) {
  var stack = this._exchanges
    , idx = 0;

  function next(err) {
    if (err) { return cb(err); }

    var layer = stack[idx++];
    if (!layer) { return cb(); }

    try {
      debug(&#x27;exchange:%s&#x27;, layer.handle.name || &#x27;anonymous&#x27;);
      if (layer.type === null || layer.type === type) {
        layer.handle(req, res, next);
      } else {
        next();
      }
    } catch (ex) {
      return cb(ex);
    }
  }
  next();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.server.prototype._parse" id="apidoc.element.oauth2orize.server.prototype._parse">
        function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>_parse
        <span class="apidocSignatureSpan">(type, req, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_parse = function (type, req, cb) {
  var ultype = new UnorderedList(type)
    , stack = this._reqParsers
    , areq = {};

  if (type) { areq.type = type; }

  (function pass(i) {
    var layer = stack[i];
    if (!layer) { return cb(null, areq); }

    try {
      debug(&#x27;parse:%s&#x27;, layer.handle.name || &#x27;anonymous&#x27;);
      if (layer.type === null || layer.type.equalTo(ultype)) {
        var arity = layer.handle.length;
        if (arity == 1) { // sync
          var o = layer.handle(req);
          utils.merge(areq, o);
          pass(i + 1);
        } else { // async
          layer.handle(req, function(err, o) {
            if (err) { return cb(err); }
            utils.merge(areq, o);
            pass(i + 1);
          });
        }
      } else {
        pass(i + 1);
      }
    } catch (ex) {
      return cb(ex);
    }
  })(0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.server.prototype._respond" id="apidoc.element.oauth2orize.server.prototype._respond">
        function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>_respond
        <span class="apidocSignatureSpan">(txn, res, complete, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_respond = function (txn, res, complete, cb) {
  if (cb === undefined) {
    cb = complete;
    complete = undefined;
  }

  var ultype = new UnorderedList(txn.req.type)
    , stack = this._resHandlers
    , idx = 0;

  function next(err) {
    if (err) { return cb(err); }

    var layer = stack[idx++];
    if (!layer) { return cb(); }

    try {
      debug(&#x27;respond:%s&#x27;, layer.handle.name || &#x27;anonymous&#x27;);
      if (layer.type === null || layer.type.equalTo(ultype)) {
        var arity = layer.handle.length;
        if (arity == 4) {
          layer.handle(txn, res, complete, next);
        } else {
          layer.handle(txn, res, next);
        }
      } else {
        next();
      }
    } catch (ex) {
      return cb(ex);
    }
  }
  next();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.server.prototype._respondError" id="apidoc.element.oauth2orize.server.prototype._respondError">
        function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>_respondError
        <span class="apidocSignatureSpan">(err, txn, res, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_respondError = function (err, txn, res, cb) {
  var ultype = new UnorderedList(txn.req.type)
    , stack = this._errHandlers
    , idx = 0;

  function next(err) {
    var layer = stack[idx++];
    if (!layer) { return cb(err); }

    try {
      debug(&#x27;error:%s&#x27;, layer.handle.name || &#x27;anonymous&#x27;);
      if (layer.type === null || layer.type.equalTo(ultype)) {
        layer.handle(err, txn, res, next);
      } else {
        next(err);
      }
    } catch (ex) {
      return cb(ex);
    }
  }
  next(err);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.server.prototype.authorization" id="apidoc.element.oauth2orize.server.prototype.authorization">
        function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>authorization
        <span class="apidocSignatureSpan">(options, validate, immediate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authorization = function (options, validate, immediate) {
  return authorization(this, options, validate, immediate);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.server.prototype.authorizationError" id="apidoc.element.oauth2orize.server.prototype.authorizationError">
        function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>authorizationError
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authorizationError = function (options) {
  var loader = transactionLoader(this, options);

  return [
    function transactionLoaderErrorWrapper(err, req, res, next) {
      loader(req, res, function(ierr) {
        return next(err);
      });
    },
    authorizationErrorHandler(this, options)
  ];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.server.prototype.authorizationErrorHandler" id="apidoc.element.oauth2orize.server.prototype.authorizationErrorHandler">
        function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>authorizationErrorHandler
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authorizationErrorHandler = function (options) {
  var loader = transactionLoader(this, options);

  return [
    function transactionLoaderErrorWrapper(err, req, res, next) {
      loader(req, res, function(ierr) {
        return next(err);
      });
    },
    authorizationErrorHandler(this, options)
  ];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.server.prototype.authorize" id="apidoc.element.oauth2orize.server.prototype.authorize">
        function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>authorize
        <span class="apidocSignatureSpan">(options, validate, immediate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authorize = function (options, validate, immediate) {
  return authorization(this, options, validate, immediate);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
When a client requests authorization, it will redirect the user to an
authorization endpoint.  The server must authenticate the user and obtain
their permission.

```javascript
app.get(&#x27;/dialog/authorize&#x27;,
login.ensureLoggedIn(),
server.<span class="apidocCodeKeywordSpan">authorize</span>(function(clientID, redirectURI, done) {
  Clients.findOne(clientID, function(err, client) {
    if (err) { return done(err); }
    if (!client) { return done(null, false); }
    if (!client.redirectUri != redirectURI) { return done(null, false); }
    return done(null, client, client.redirectURI);
  });
}),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.server.prototype.authorizeError" id="apidoc.element.oauth2orize.server.prototype.authorizeError">
        function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>authorizeError
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authorizeError = function (options) {
  var loader = transactionLoader(this, options);

  return [
    function transactionLoaderErrorWrapper(err, req, res, next) {
      loader(req, res, function(ierr) {
        return next(err);
      });
    },
    authorizationErrorHandler(this, options)
  ];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.server.prototype.decision" id="apidoc.element.oauth2orize.server.prototype.decision">
        function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>decision
        <span class="apidocSignatureSpan">(options, parse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decision = function (options, parse) {
  if (options &#x26;&#x26; options.loadTransaction === false) {
    return decision(this, options, parse);
  }
  return [transactionLoader(this, options), decision(this, options, parse)];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
authorization proceeds.  At that point, the application renders a dialog
asking the user to grant access.  The resulting form submission is processed
using `decision` middleware.

```javascript
app.post(&#x27;/dialog/authorize/decision&#x27;,
   login.ensureLoggedIn(),
   server.<span class="apidocCodeKeywordSpan">decision</span>());
```

Based on the grant type requested by the client, the appropriate grant
module registered above will be invoked to issue an authorization code.

#### Session Serialization
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.server.prototype.deserializeClient" id="apidoc.element.oauth2orize.server.prototype.deserializeClient">
        function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>deserializeClient
        <span class="apidocSignatureSpan">(fn, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deserializeClient = function (fn, done) {
  if (typeof fn === &#x27;function&#x27;) {
    return this._deserializers.push(fn);
  }

  // private implementation that traverses the chain of deserializers,
  // attempting to deserialize a client
  var obj = fn;

  var stack = this._deserializers;
  (function pass(i, err, client) {
    // deserializers use &#x27;pass&#x27; as an error to skip processing
    if (&#x27;pass&#x27; === err) { err = undefined; }
    // an error or deserialized client was obtained, done
    if (err || client) { return done(err, client); }
    // a valid client existed when establishing the session, but that client has
    // since been deauthorized
    if (client === null || client === false) { return done(null, false); }

    var layer = stack[i];
    if (!layer) {
      return done(new Error(&#x27;Failed to deserialize client. Register deserialization function using deserializeClient().&#x27;));
    }

    try {
      layer(obj, function(e, c) { pass(i + 1, e, c); } );
    } catch (ex) {
      return done(ex);
    }
  })(0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
by ID when deserializing.

```javascript
server.serializeClient(function(client, done) {
  return done(null, client.id);
});

server.<span class="apidocCodeKeywordSpan">deserializeClient</span>(function(id, done) {
  Clients.findOne(id, function(err, client) {
    if (err) { return done(err); }
    return done(null, client);
  });
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.server.prototype.errorHandler" id="apidoc.element.oauth2orize.server.prototype.errorHandler">
        function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>errorHandler
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">errorHandler = function (options) {
  return errorHandler(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Once a user has approved access, the authorization grant can be exchanged by the
client for an access token.

```javascript
app.post(&#x27;/token&#x27;,
  passport.authenticate([&#x27;basic&#x27;, &#x27;oauth2-client-password&#x27;], { session: false }),
  server.token(),
  server.<span class="apidocCodeKeywordSpan">errorHandler</span>());
```

[Passport](http://passportjs.org/) strategies are used to authenticate the
client, in this case using either an HTTP Basic authentication header (as
provided by [passport-http](https://github.com/jaredhanson/passport-http)) or
client credentials in the request body (as provided by
[passport-oauth2-client-password](https://github.com/jaredhanson/passport-oauth2-client-password)).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.server.prototype.exchange" id="apidoc.element.oauth2orize.server.prototype.exchange">
        function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>exchange
        <span class="apidocSignatureSpan">(type, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exchange = function (type, fn) {
  if (typeof type == &#x27;function&#x27;) {
    fn = type;
    type = fn.name;
  }
  if (type === &#x27;*&#x27;) { type = null; }

  debug(&#x27;register exchanger %s %s&#x27;, type || &#x27;*&#x27;, fn.name || &#x27;anonymous&#x27;);
  this._exchanges.push({ type: type, handle: fn });
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### Register Exchanges

After a client has obtained an authorization grant from the user, that grant can
be exchanged for an access token.

```javascript
server.<span class="apidocCodeKeywordSpan">exchange</span>(oauth2orize.exchange.code(function(client, code, redirectURI, done) {
  AuthorizationCode.findOne(code, function(err, code) {
if (err) { return done(err); }
if (client.id !== code.clientId) { return done(null, false); }
if (redirectURI !== code.redirectUri) { return done(null, false); }

var token = utils.uid(256);
var at = new AccessToken(token, code.userId, code.clientId, code.scope);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.server.prototype.grant" id="apidoc.element.oauth2orize.server.prototype.grant">
        function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>grant
        <span class="apidocSignatureSpan">(type, phase, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">grant = function (type, phase, fn) {
  if (typeof type == &#x27;object&#x27;) {
    // sig: grant(mod)
    var mod = type;
    if (mod.request) { this.grant(mod.name, &#x27;request&#x27;, mod.request); }
    if (mod.response) { this.grant(mod.name, &#x27;response&#x27;, mod.response); }
    if (mod.error) { this.grant(mod.name, &#x27;error&#x27;, mod.error); }
    return this;
  }
  if (typeof phase == &#x27;object&#x27;) {
    // sig: grant(type, mod)
    var mod = phase;
    if (mod.request) { this.grant(type, &#x27;request&#x27;, mod.request); }
    if (mod.response) { this.grant(type, &#x27;response&#x27;, mod.response); }
    if (mod.error) { this.grant(type, &#x27;error&#x27;, mod.error); }
    return this;
  }

  if (typeof phase == &#x27;function&#x27;) {
    // sig: grant(type, fn)
    fn = phase;
    phase = &#x27;request&#x27;;
  }
  if (type === &#x27;*&#x27;) { type = null; }
  if (type) { type = new UnorderedList(type); }

  if (phase == &#x27;request&#x27;) {
    debug(&#x27;register request parser %s %s&#x27;, type || &#x27;*&#x27;, fn.name || &#x27;anonymous&#x27;);
    this._reqParsers.push({ type: type, handle: fn });
  } else if (phase == &#x27;response&#x27;) {
    debug(&#x27;register response handler %s %s&#x27;, type || &#x27;*&#x27;, fn.name || &#x27;anonymous&#x27;);
    this._resHandlers.push({ type: type, handle: fn });
  } else if (phase == &#x27;error&#x27;) {
    debug(&#x27;register error handler %s %s&#x27;, type || &#x27;*&#x27;, fn.name || &#x27;anonymous&#x27;);
    this._errHandlers.push({ type: type, handle: fn });
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### Register Grants

A client must obtain permission from a user before it is issued an access token.
This permission is known as a grant, the most common type of which is an
authorization code.
```javascript
server.<span class="apidocCodeKeywordSpan">grant</span>(oauth2orize.grant.code(function(client, redirectURI, user, ares, done) {
var code = utils.uid(16);

var ac = new AuthorizationCode(code, client.id, redirectURI, user.id, ares.scope);
ac.save(function(err) {
  if (err) { return done(err); }
  return done(null, code);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.server.prototype.resume" id="apidoc.element.oauth2orize.server.prototype.resume">
        function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>resume
        <span class="apidocSignatureSpan">(options, immediate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function (options, immediate) {
  if (options &#x26;&#x26; options.loadTransaction === false) {
    return resume(this, options, immediate);
  }
  return [transactionLoader(this, options), resume(this, options, immediate)];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.server.prototype.serializeClient" id="apidoc.element.oauth2orize.server.prototype.serializeClient">
        function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>serializeClient
        <span class="apidocSignatureSpan">(fn, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serializeClient = function (fn, done) {
  if (typeof fn === &#x27;function&#x27;) {
    return this._serializers.push(fn);
  }

  // private implementation that traverses the chain of serializers, attempting
  // to serialize a client
  var client = fn;

  var stack = this._serializers;
  (function pass(i, err, obj) {
    // serializers use &#x27;pass&#x27; as an error to skip processing
    if (&#x27;pass&#x27; === err) { err = undefined; }
    // an error or serialized object was obtained, done
    if (err || obj) { return done(err, obj); }

    var layer = stack[i];
    if (!layer) {
      return done(new Error(&#x27;Failed to serialize client. Register serialization function using serializeClient().&#x27;));
    }

    try {
      layer(client, function(e, o) { pass(i + 1, e, o); } );
    } catch (ex) {
      return done(ex);
    }
  })(0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Obtaining the user&#x27;s authorization involves multiple request/response pairs.
During this time, an OAuth 2.0 transaction will be serialized to the session.
Client serialization functions are registered to customize this process, which
will typically be as simple as serializing the client ID, and finding the client
by ID when deserializing.

```javascript
server.<span class="apidocCodeKeywordSpan">serializeClient</span>(function(client, done) {
return done(null, client.id);
});

server.deserializeClient(function(id, done) {
Clients.findOne(id, function(err, client) {
  if (err) { return done(err); }
  return done(null, client);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.server.prototype.token" id="apidoc.element.oauth2orize.server.prototype.token">
        function <span class="apidocSignatureSpan">oauth2orize.server.prototype.</span>token
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">token = function (options) {
  return token(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Once a user has approved access, the authorization grant can be exchanged by the
client for an access token.

```javascript
app.post(&#x27;/token&#x27;,
  passport.authenticate([&#x27;basic&#x27;, &#x27;oauth2-client-password&#x27;], { session: false }),
  server.<span class="apidocCodeKeywordSpan">token</span>(),
  server.errorHandler());
```

[Passport](http://passportjs.org/) strategies are used to authenticate the
client, in this case using either an HTTP Basic authentication header (as
provided by [passport-http](https://github.com/jaredhanson/passport-http)) or
client credentials in the request body (as provided by
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.oauth2orize.unorderedlist" id="apidoc.module.oauth2orize.unorderedlist">module oauth2orize.unorderedlist</a></h1>


    <h2>
        <a href="#apidoc.element.oauth2orize.unorderedlist.unorderedlist" id="apidoc.element.oauth2orize.unorderedlist.unorderedlist">
        function <span class="apidocSignatureSpan">oauth2orize.</span>unorderedlist
        <span class="apidocSignatureSpan">(items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function UnorderedList(items) {
  if (typeof items == &#x27;string&#x27;) {
    items = items.split(&#x27; &#x27;);
  }
  this._items = items || [];
  this.__defineGetter__(&#x27;length&#x27;, this._length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.oauth2orize.unorderedlist.prototype" id="apidoc.module.oauth2orize.unorderedlist.prototype">module oauth2orize.unorderedlist.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.oauth2orize.unorderedlist.prototype._length" id="apidoc.element.oauth2orize.unorderedlist.prototype._length">
        function <span class="apidocSignatureSpan">oauth2orize.unorderedlist.prototype.</span>_length
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_length = function () {
  return this._items.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.unorderedlist.prototype.contains" id="apidoc.element.oauth2orize.unorderedlist.prototype.contains">
        function <span class="apidocSignatureSpan">oauth2orize.unorderedlist.prototype.</span>contains
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">contains = function (val) {
  return this._items.indexOf(val) != -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.unorderedlist.prototype.containsAny" id="apidoc.element.oauth2orize.unorderedlist.prototype.containsAny">
        function <span class="apidocSignatureSpan">oauth2orize.unorderedlist.prototype.</span>containsAny
        <span class="apidocSignatureSpan">(arr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">containsAny = function (arr) {
  for (var i = 0, len = arr.length; i &#x3c; len; i++) {
    if (this._items.indexOf(arr[i]) != -1) { return true; }
  }
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.unorderedlist.prototype.equalTo" id="apidoc.element.oauth2orize.unorderedlist.prototype.equalTo">
        function <span class="apidocSignatureSpan">oauth2orize.unorderedlist.prototype.</span>equalTo
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">equalTo = function (other) {
  if (!(other instanceof UnorderedList)) {
    other = new UnorderedList(other);
  }

  if (this.length != other.length) { return false; }
  for (var i = 0, len = this._items.length; i &#x3c; len; i++) {
    var item = this._items[i];
    if (other._items.indexOf(item) == -1) {
      return false;
    }
  }
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  (function pass(i) {
var layer = stack[i];
if (!layer) { return cb(null, areq); }

try {
  debug(&#x27;parse:%s&#x27;, layer.handle.name || &#x27;anonymous&#x27;);
  if (layer.type === null || layer.type.<span class="apidocCodeKeywordSpan">equalTo</span>(ultype)) {
    var arity = layer.handle.length;
    if (arity == 1) { // sync
      var o = layer.handle(req);
      utils.merge(areq, o);
      pass(i + 1);
    } else { // async
      layer.handle(req, function(err, o) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.unorderedlist.prototype.toString" id="apidoc.element.oauth2orize.unorderedlist.prototype.toString">
        function <span class="apidocSignatureSpan">oauth2orize.unorderedlist.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return this._items.join(&#x27; &#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.oauth2orize.utils" id="apidoc.module.oauth2orize.utils">module oauth2orize.utils</a></h1>


    <h2>
        <a href="#apidoc.element.oauth2orize.utils.merge" id="apidoc.element.oauth2orize.utils.merge">
        function <span class="apidocSignatureSpan">oauth2orize.utils.</span>merge
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge = function (a, b){
  if (a &#x26;&#x26; b) {
    for (var key in b) {
      a[key] = b[key];
    }
  }
  return a;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    try {
debug(&#x27;parse:%s&#x27;, layer.handle.name || &#x27;anonymous&#x27;);
if (layer.type === null || layer.type.equalTo(ultype)) {
  var arity = layer.handle.length;
  if (arity == 1) { // sync
    var o = layer.handle(req);
    utils.<span class="apidocCodeKeywordSpan">merge</span>(areq, o);
    pass(i + 1);
  } else { // async
    layer.handle(req, function(err, o) {
      if (err) { return cb(err); }
      utils.merge(areq, o);
      pass(i + 1);
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.oauth2orize.utils.uid" id="apidoc.element.oauth2orize.utils.uid">
        function <span class="apidocSignatureSpan">oauth2orize.utils.</span>uid
        <span class="apidocSignatureSpan">(length, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function uid(length, cb) {

  if (typeof cb === &#x27;undefined&#x27;) {
    return tostr(crypto.pseudoRandomBytes(length));
  } else {
    crypto.pseudoRandomBytes(length, function(err, bytes) {
       if (err) return cb(err);
       cb(null, tostr(bytes));
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
#### Register Grants

A client must obtain permission from a user before it is issued an access token.
This permission is known as a grant, the most common type of which is an
authorization code.
```javascript
server.grant(oauth2orize.grant.code(function(client, redirectURI, user, ares, done) {
  var code = utils.<span class="apidocCodeKeywordSpan">uid</span>(16);

  var ac = new AuthorizationCode(code, client.id, redirectURI, user.id, ares.scope);
  ac.save(function(err) {
    if (err) { return done(err); }
    return done(null, code);
  });
}));
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
